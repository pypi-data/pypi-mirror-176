#!python
# This file is placed in the Public Domain.


import atexit
import os
import readline
import rlcompleter
import signal
import sys
import termios
import time


sys.path.insert(0, os.getcwd())


from op import Class, Wd, keys, last, printable, update
from op import Cfg, Command, Event, Handler, parse, scan
from operbot import cmds, irc, rss


Wd.workdir = os.path.expanduser("~/.operbot")


scan(cmds)
scan(irc)
scan(rss)


class Console(Handler):

    @staticmethod
    def announce(txt):
        pass

    @staticmethod
    def handle(event):
        Command.handle(event)
        event.wait()

    def poll(self):
        event = Event()
        event.txt = input("> ")
        event.orig = repr(self)
        return event

    @staticmethod
    def raw(txt):
        print(txt)


class Completer(rlcompleter.Completer):

    def __init__(self, options):
        super().__init__()
        self.options = options
 
    def complete(self, text, state):
        if state == 0:
            if text:
                self.matches = [s for s in self.options if s and s.startswith(text)]
            else:
                self.matches = self.options[:]
        try:
            return self.matches[state]
        except IndexError:
            return None


def banner(cfg):
    print(
          "OPERBOT started at %s %s" % (
                                     time.ctime(time.time()).replace("  ", " "),
                                     printable(cfg, "debug,verbose")
                                    )
         )


def boot():
    signal.signal(signal.SIGHUP, hup)
    setcompleter(keys(Command.cmd))
    txt = ' '.join(sys.argv[1:])
    cfg = parse(txt)
    update(Cfg, cfg)
    banner(cfg)
    return cfg

def hup(_sig, _frame):
    print("signal 15 called")
    sys.stdout.flush()


def isopt(ostr):
    for opt in ostr:
        if opt in Cfg.opts:
            return True
    return False


def setcompleter(optionlist):
    completer = Completer(optionlist)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))


def wrap(func):
    fds = sys.stdin.fileno()
    gotterm = True
    try:
        old = termios.tcgetattr(fds)
    except termios.error:
        gotterm = False
    readline.redisplay()
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        if gotterm:
            termios.tcsetattr(fds, termios.TCSADRAIN, old)


def main():
    boot()
    bot = irc.init()
    print(printable(bot.cfg, "nick,channel,server,port,sasl"))
    rss.init()
    csl = Console()
    csl.start()
    csl.wait()
        

wrap(main)
