"""
Report Handler
"""

from typing import Optional

import logging
from datetime import datetime, timedelta
from pathlib import Path

import typer

from laceworkreports import common
from laceworkreports.sdk.DataHandlers import DataHandlerTypes, ExportHandler
from laceworkreports.sdk.ReportHelpers import (
    ContainerVulnerabilityQueries,
    ReportHelper,
    ReportSeverityTypes,
)

app: typer.Typer = typer.Typer(no_args_is_help=True)


@app.command(no_args_is_help=True, help="Generate HTML report")
def html(
    ctx: typer.Context,
    start_time: datetime = typer.Option(
        (datetime.utcnow() - timedelta(hours=25)).strftime(common.ISO_FORMAT),
        formats=[common.ISO_FORMAT],
        help="Start time for query period",
    ),
    end_time: datetime = typer.Option(
        (datetime.utcnow()).strftime(common.ISO_FORMAT),
        formats=[common.ISO_FORMAT],
        help="End time for query period",
    ),
    fixable: bool = typer.Option(True, help="Return only fixable vulnerabilities"),
    severity: ReportSeverityTypes = typer.Option(
        ReportSeverityTypes.HIGH.value,
        help="Return only vulnerabilities with at or above the severity threshold",
    ),
    namespace: Optional[str] = typer.Option(
        None,
        help="Return only vulnerabilities matching package namespace",
    ),
    cve: Optional[str] = typer.Option(
        None,
        help="Return only vulnerabilities matching cve",
    ),
    subaccounts: bool = typer.Option(
        False,
        help="Enumerate subaccounts",
        envvar=common.LACEWORK_REPORTS_SUBACCOUNTS,
    ),
    file_path: str = typer.Option(
        ...,
        help="Path to exported result",
        envvar=common.LACEWORK_REPORTS_FILE_PATH,
    ),
    template_path: str = typer.Option(
        Path(__file__)
        .resolve()
        .parent.joinpath("container_vulnerability_coverage.html.j2"),
        help="Path to jinja2 template. Results will be passed as 'dataset' variable.",
        envvar=common.LACEWORK_REPORTS_TEMPLATE_PATH,
    ),
    ignore_errors: bool = typer.Option(
        True,
        help="Ignore error for missing reports or inaccessible account details.",
    ),
) -> None:
    """
    Set the command context
    """

    # connect lacework client
    lw = common.config.connect()

    # report details - uses sqlite for initial sync and report due to datasize
    db_table = "container_vulnerability_coverage"
    report_title = "Container Vulnerability Coverage"
    reportHelper = ReportHelper()
    db_path = Path("database.db")
    # db_path.unlink(missing_ok=True)
    db_connection = f"sqlite:///{db_path.absolute()}?check_same_thread=False"

    reportHelper.sqlite_drop_table(db_table, db_connection)
    reportHelper.sqlite_drop_table("active_cloud_accounts", db_connection)
    reportHelper.sqlite_drop_table("cloud_accounts", db_connection)
    reportHelper.sqlite_drop_table("containers", db_connection)

    has_subaccounts = False
    if subaccounts:
        lwAccounts = reportHelper.get_subaccounts(client=lw)
        if len(lwAccounts) == 0:
            logging.error("Subaccounts specificed but none found")
            raise Exception("Subaccounts specificed but none found")
        else:
            has_subaccounts = True
    else:
        lwAccounts = [{"accountName": lw._account}]

    lacework_account_count = 0
    for lwAccount in lwAccounts:
        lacework_account_count += 1
        if has_subaccounts:
            logging.info(f"Switching to subaccount context: {lwAccount['accountName']}")
            lw.set_subaccount(lwAccount["accountName"])

        # sync cloud accounts with deployed agents
        logging.info("Syncing cloud accounts with deployed agents")
        reportHelper.get_active_cloud_accounts(
            client=lw,
            lwAccount=lwAccount["accountName"],
            start_time=start_time,
            end_time=end_time,
            use_sqlite=True,
            db_table="active_cloud_accounts",
            db_connection=db_connection,
        )
        try:
            result = reportHelper.sqlite_queries(
                queries={
                    "cloud_account_query": """
                                    SELECT 
                                        DISTINCT ACCOUNTID
                                    FROM 
                                        :db_table
                                    WHERE 
                                        ACCOUNTID IS NOT NULL
                                    """
                },
                db_connection=db_connection,
                db_table="active_cloud_accounts",
            )
            active_cloud_accounts = [
                x["ACCOUNTID"] for x in result["cloud_account_query"]
            ]
        except Exception:
            active_cloud_accounts = []

        # get cloud accounts and sync to sqlite
        cloud_accounts = reportHelper.get_cloud_accounts(
            client=lw, lwAccount=lwAccount["accountName"]
        )
        ExportHandler(
            format=DataHandlerTypes.SQLITE,
            results=[{"data": cloud_accounts}],
            file_path=file_path,
            db_table="cloud_accounts",
            db_connection=db_connection,
        ).export()

        logging.info(
            f"Discovered {len(active_cloud_accounts)} cloud accounts with agents deployed: {active_cloud_accounts}"
        )

        for cloud_account in cloud_accounts:

            if (
                cloud_account["enabled"] == 1
                and cloud_account["accountId"] in active_cloud_accounts
            ):
                # sync machines for this cloud account
                logging.info(
                    f"Syncing machines for {lwAccount['accountName']}:{cloud_account['accountId']}"
                )

                reportHelper.get_active_containers(
                    client=lw,
                    lwAccount=lwAccount["accountName"],
                    cloud_account=cloud_account["accountId"],
                    start_time=start_time,
                    end_time=end_time,
                    use_sqlite=True,
                    db_table="containers",
                    db_connection=db_connection,
                )

                reportHelper.get_container_vulnerability_report(
                    client=lw,
                    lwAccount=lwAccount["accountName"],
                    cloud_account=cloud_account["accountId"],
                    ignore_errors=ignore_errors,
                    start_time=start_time,
                    end_time=end_time,
                    fixable=fixable,
                    namespace=namespace,
                    severity=severity,
                    cve=cve,
                    use_sqlite=True,
                    db_table=db_table,
                    db_connection=db_connection,
                )

                # ensure we have machines table if no machines were found
                if not reportHelper.sqlite_table_exists(
                    db_table="containers", db_connection=db_connection
                ):
                    containers_table = """
                                        CREATE TABLE containers (
                                            "LWACCOUNT" TEXT, 
                                            "ACCOUNTID" TEXT, 
                                            "IMAGE_ID" TEXT
                                        )
                                        """
                    reportHelper.sqlite_execute(
                        query=containers_table, db_connection=db_connection
                    )

                # ensure we have a vulnerability_coverage table
                if not reportHelper.sqlite_table_exists(
                    db_table="container_vulnerability_coverage",
                    db_connection=db_connection,
                ):
                    container_vulnerability_coverage_table = """
                                                    CREATE TABLE container_vulnerability_coverage (
                                                        start_time TEXT, 
                                                        image_id TEXT, 
                                                        "vulnId" TEXT, 
                                                        image_registry TEXT, 
                                                        image_repo TEXT, 
                                                        image_status TEXT, 
                                                        package_name TEXT, 
                                                        package_namespace TEXT, 
                                                        version TEXT, 
                                                        fix_available BIGINT, 
                                                        fixed_version TEXT, 
                                                        severity TEXT, 
                                                        status TEXT
                                                    , accountId TEXT, lwAccount TEXT)
                                                    """
                    reportHelper.sqlite_execute(
                        query=container_vulnerability_coverage_table,
                        db_connection=db_connection,
                    )
            else:
                logging.info(
                    f"Skipping disabled or inactive account {lwAccount['accountName']}:{cloud_account['accountId']}"
                )

    # use sqlite query to generate final result
    results = reportHelper.sqlite_queries(
        queries=ContainerVulnerabilityQueries,
        db_table=db_table,
        db_connection=db_connection,
    )

    if len(results["report"]) > 0:
        report = results["report"]

        # return additional stats under summary
        stats = {}
        for key in [x for x in results.keys() if x != "report"]:
            stats[key] = results[key]

        # write jinja template
        ExportHandler(
            format=DataHandlerTypes.JINJA2,
            results=[
                {
                    "data": [
                        {
                            "name": db_table,
                            "report": report,
                            "summary": {
                                "rows": len(report),
                                "reportTitle": report_title,
                                "stats": stats,
                            },
                        }
                    ]
                }
            ],
            template_path=template_path,
            file_path=file_path,
        ).export()
    else:
        logging.warn("No report results found.")


@app.command(name="csv", no_args_is_help=True, help="Generate CSV Report")
def csv_handler(
    ctx: typer.Context,
    start_time: datetime = typer.Option(
        (datetime.utcnow() - timedelta(hours=25)).strftime(common.ISO_FORMAT),
        formats=[common.ISO_FORMAT],
        help="Start time for query period",
    ),
    end_time: datetime = typer.Option(
        (datetime.utcnow()).strftime(common.ISO_FORMAT),
        formats=[common.ISO_FORMAT],
        help="End time for query period",
    ),
    fixable: bool = typer.Option(True, help="Return only fixable vulnerabilities"),
    severity: ReportSeverityTypes = typer.Option(
        ReportSeverityTypes.HIGH.value,
        help="Return only vulnerabilities with at or above the severity threshold",
    ),
    namespace: Optional[str] = typer.Option(
        None,
        help="Return only vulnerabilities matching package namespace",
    ),
    cve: Optional[str] = typer.Option(
        None,
        help="Return only vulnerabilities matching cve",
    ),
    subaccounts: bool = typer.Option(
        False,
        help="Enumerate subaccounts",
        envvar=common.LACEWORK_REPORTS_SUBACCOUNTS,
    ),
    summary_only: bool = typer.Option(
        False,
        help="Return only summary details",
        envvar=common.LACEWORK_REPORTS_SUBACCOUNTS,
    ),
    file_path: str = typer.Option(
        ...,
        help="Path to exported result",
        envvar=common.LACEWORK_REPORTS_FILE_PATH,
    ),
    ignore_errors: bool = typer.Option(
        True,
        help="Ignore error for missing reports or inaccessible account details.",
    ),
) -> None:
    """
    Set the command context
    """

    # connect lacework client
    lw = common.config.connect()

    # report details - uses sqlite for initial sync and report due to datasize
    db_table = "container_vulnerability_coverage"
    reportHelper = ReportHelper()
    db_path = Path("database.db")
    # db_path.unlink(missing_ok=True)
    db_connection = f"sqlite:///{db_path.absolute()}?check_same_thread=False"

    reportHelper.sqlite_drop_table(db_table, db_connection)
    reportHelper.sqlite_drop_table("active_cloud_accounts", db_connection)
    reportHelper.sqlite_drop_table("cloud_accounts", db_connection)
    reportHelper.sqlite_drop_table("containers", db_connection)

    has_subaccounts = False
    if subaccounts:
        lwAccounts = reportHelper.get_subaccounts(client=lw)
        if len(lwAccounts) == 0:
            logging.error("Subaccounts specificed but none found")
            raise Exception("Subaccounts specificed but none found")
        else:
            has_subaccounts = True
    else:
        lwAccounts = [{"accountName": lw._account}]

    lacework_account_count = 0
    for lwAccount in lwAccounts:
        lacework_account_count += 1
        if has_subaccounts:
            logging.info(f"Switching to subaccount context: {lwAccount['accountName']}")
            lw.set_subaccount(lwAccount["accountName"])

        # sync cloud accounts with deployed agents
        logging.info("Syncing cloud accounts with deployed agents")
        reportHelper.get_active_cloud_accounts(
            client=lw,
            lwAccount=lwAccount["accountName"],
            start_time=start_time,
            end_time=end_time,
            use_sqlite=True,
            db_table="active_cloud_accounts",
            db_connection=db_connection,
        )
        try:
            result = reportHelper.sqlite_queries(
                queries={
                    "cloud_account_query": """
                                    SELECT 
                                        DISTINCT ACCOUNTID
                                    FROM 
                                        :db_table
                                    WHERE 
                                        ACCOUNTID IS NOT NULL
                                    """
                },
                db_connection=db_connection,
                db_table="active_cloud_accounts",
            )
            active_cloud_accounts = [
                x["ACCOUNTID"] for x in result["cloud_account_query"]
            ]
        except Exception:
            active_cloud_accounts = []

        # get cloud accounts and sync to sqlite
        cloud_accounts = reportHelper.get_cloud_accounts(
            client=lw, lwAccount=lwAccount["accountName"]
        )
        ExportHandler(
            format=DataHandlerTypes.SQLITE,
            results=[{"data": cloud_accounts}],
            file_path=file_path,
            db_table="cloud_accounts",
            db_connection=db_connection,
        ).export()

        logging.info(
            f"Discovered {len(active_cloud_accounts)} cloud accounts with agents deployed: {active_cloud_accounts}"
        )

        for cloud_account in cloud_accounts:
            quick_match = (
                cloud_account["accountId"].split(":")[0]
                + ":"
                + cloud_account["accountId"].split(":")[-1]
            )

            if cloud_account["enabled"] == 1 and quick_match in active_cloud_accounts:
                # sync machines for this cloud account
                logging.info(
                    f"Syncing machines for {lwAccount['accountName']}:{cloud_account['accountId']}"
                )

                reportHelper.get_active_containers(
                    client=lw,
                    lwAccount=lwAccount["accountName"],
                    cloud_account=cloud_account["accountId"],
                    start_time=start_time,
                    end_time=end_time,
                    use_sqlite=True,
                    db_table="containers",
                    db_connection=db_connection,
                )

                reportHelper.get_container_vulnerability_report(
                    client=lw,
                    lwAccount=lwAccount["accountName"],
                    cloud_account=cloud_account["accountId"],
                    ignore_errors=ignore_errors,
                    start_time=start_time,
                    end_time=end_time,
                    fixable=fixable,
                    namespace=namespace,
                    severity=severity,
                    cve=cve,
                    use_sqlite=True,
                    db_table=db_table,
                    db_connection=db_connection,
                )

                # ensure we have machines table if no machines were found
                if not reportHelper.sqlite_table_exists(
                    db_table="containers", db_connection=db_connection
                ):
                    containers_table = """
                                        CREATE TABLE containers (
                                            "LWACCOUNT" TEXT, 
                                            "ACCOUNTID" TEXT, 
                                            "IMAGE_ID" TEXT
                                        )
                                        """
                    reportHelper.sqlite_execute(
                        query=containers_table, db_connection=db_connection
                    )

                # ensure we have a vulnerability_coverage table
                if not reportHelper.sqlite_table_exists(
                    db_table="container_vulnerability_coverage",
                    db_connection=db_connection,
                ):
                    container_vulnerability_coverage_table = """
                                                    CREATE TABLE container_vulnerability_coverage (
                                                        start_time TEXT, 
                                                        image_id TEXT, 
                                                        "vulnId" TEXT, 
                                                        image_registry TEXT, 
                                                        image_repo TEXT, 
                                                        image_status TEXT, 
                                                        package_name TEXT, 
                                                        package_namespace TEXT, 
                                                        version TEXT, 
                                                        fix_available BIGINT, 
                                                        fixed_version TEXT, 
                                                        severity TEXT, 
                                                        status TEXT
                                                    , accountId TEXT, lwAccount TEXT)
                                                    """
                    reportHelper.sqlite_execute(
                        query=container_vulnerability_coverage_table,
                        db_connection=db_connection,
                    )

            else:
                logging.info(
                    f"Skipping disabled or inactive account {lwAccount['accountName']}:{cloud_account['accountId']}"
                )

    # use sqlite query to generate final result
    results = reportHelper.sqlite_queries(
        queries=ContainerVulnerabilityQueries,
        db_table=db_table,
        db_connection=db_connection,
    )

    if len(results["report"]) > 0:
        if summary_only:
            report = results["account_coverage"]
        else:
            report = results["report"]

        logging.info("Building CSV from resultant data...")
        ExportHandler(
            format=DataHandlerTypes.CSV,
            results=[{"data": report}],
            file_path=file_path,
        ).export()
    else:
        logging.warn("No report results found.")


if __name__ == "__main__":
    app()
