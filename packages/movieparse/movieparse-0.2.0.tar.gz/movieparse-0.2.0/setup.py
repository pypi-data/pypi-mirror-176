# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['movieparse']

package_data = \
{'': ['*']}

install_requires = \
['pandas>=1.5.1,<2.0.0',
 'pathlib>=1.0.1,<2.0.0',
 'requests>=2.28.1,<3.0.0',
 'tqdm>=4.64.1,<5.0.0']

entry_points = \
{'console_scripts': ['movieparse = movieparse.cli:main']}

setup_kwargs = {
    'name': 'movieparse',
    'version': '0.2.0',
    'description': 'movieparse is a lazy utility for fetching bulk movie data from TMDB.',
    'long_description': '![Test Badge](https://github.com/tilschuenemann/movieparse/actions/workflows/CICD.yml/badge.svg)\n[![CodeCov](https://codecov.io/gh/tilschuenemann/movieparse/branch/coverage/graph/badge.svg?token=B5M10X5EV9)](https://codecov.io/gh/tilschuenemann/movieparse)\n\n# movieparse\n\n`movieparse` is a lazy utility for fetching bulk movie data from [TMDB](https://www.themoviedb.org/) using movie release year and title. It has both an\nPython API and CLI.\n\n## Installation & Requirements\n\n```bash\npip install movieparse\n```\n\nYou\'ll need to have a TMDB API key in order to make API requests. Either specify it explicitly or add it as environment variable:\n\n```bash\nexport TMDB_API_KEY="your_api_key_here"\n```\n\n## Usage\n\nThis program assumes that your root movie folder looks like this:\n\n```\nroot_movie_dir/\n    1999 The Matrix/\n        thematrix.mkv\n    1999 Fight Club/\n        fightclub-part1.mkv\n        fightclub-part2.mkv\n        fightclub.srt\n```\n\nContents inside the subfolder aren\'t taken into consideration. Running without further options:\n\n```bash\nmovieparse root_movie_dir/\n```\n\nAdditional options:\n\n```bash\nmovieparse -h\nusage: tmdb_parser [-h] [--root_movie_dir [ROOT_MOVIE_DIR] | --movie_list MOVIE_LIST [MOVIE_LIST ...]] [--tmdb_api_key [TMDB_API_KEY]]\n                   [--parsing_style [{0,1}]] [--output_path [OUTPUT_PATH]] [--lax] [--language [LANGUAGE]] [--eager]\n\noptions:\n  -h, --help            show this help message and exit\n  --root_movie_dir [ROOT_MOVIE_DIR]\n                        Directory containing your movie folders.\n  --movie_list MOVIE_LIST [MOVIE_LIST ...]\n                        Alternative to root_movie_dir, takes list of strings with movie title and optionally movie release year.\n  --tmdb_api_key [TMDB_API_KEY]\n                        TMDB API key. If not supplied here, environment variable TMDB_API_KEY will be read.\n  --parsing_style [{0,1}]\n                        Naming convention used - see documentation for examples.\n  --output_path [OUTPUT_PATH]\n                        Path to directory where output CSVs get written to. Defaults to current directory.\n  --lax                 Use if TMDB ID lookup should fall back to title only (instead of year+title). Results may not be as accurate.\n  --language [LANGUAGE]\n                        ISO-639-1 language shortcode for specifying result language. Defaults to en_US.\n  --eager               Using this will refetch all IDs and metadata without accessing the cache.\n```\n\n## Features\n\n### Different Naming Conventions Supported\n\nCurrently these naming conventions are supported:\n\n| parsing_style | Example           |\n| ------------- | ----------------- |\n| 0             | 1999 The Matrix   |\n| 1             | 1999 - The Matrix |\n\nEvery parsing style is a regex pattern - incase you want to use a parsing style that\'s not supported, create a pull request and add yours!\n\n### Custom Lookup\n\nAfter parsing your files, take a look into mapping.csv:\n\n| item                            | tmdb_id | tmdb_id_man |\n| ------------------------------- | ------- | ----------- |\n| /root_movie_dir/1999 The Martix | -1      | 0           |\n\nFor some movies the correct TMDB Id cant be looked up due to bad spelling or old year-title combinations. For these movies\nyou can add the _tmdb_id_man_ manually:\n\n| item                            | tmdb_id | tmdb_id_man |\n| ------------------------------- | ------- | ----------- |\n| /root_movie_dir/1999 The Martix | -1      | _603_       |\n\nThe next time you use `movieparse` the manual id will be looked up.\n\n### Caching\n\nIf you ran `movieparse` successfully, the mapping and metadata files will be written to disk. The next time you run it, only new paths will be appended to your mapping and metadata will be only looked up if it\'s not present in the current metadata.\n\nYou can disable this behavior by using the `--eager` flag in the CLI.\n\n### Schemas\n\nThe following files will be written:\n\n```\nmapping.csv                         genres.csv\n    tmdb_id                             genres.id\n    tmdb_id_man                         genres.name\n    item                                tmdb_id\n\ndetails.csv                         spoken_languages.csv\n    adult                               spoken_languages.english_name\n    backdrop_path                       spoken_languages.iso_639_1\n    budget                              spoken_languages.name\n    homepage                            tmdb_id\n    imdb_id\n    original_language\n    original_title                  production_companies.csv\n    overview                            production_companies.id\n    popularity                          production_companies.logo_path\n    poster_path                         production_companies.name\n    release_date                        production_companies.origin_country\n    revenue                             tmdb_id\n    runtime\n    status                          production_countries.csv\n    tagline                             production_countries.iso_3166_1\n    title                               production_countries.name\n    video                               tmdb_id\n    vote_average\n    vote_count                      collections.csv\n    tmdb_id                             collection.id\n                                        collection.name\n                                        collection.poster_path\n                                        collection.backdrop_path\n                                        tmdb_id\n\ncast.csv                            crew.csv\n    cast.adult                          crew.adult\n    cast.gender                         crew.gender\n    cast.id                             crew.id\n    cast.known_for_department           crew.known_for_department\n    cast.name                           crew.name\n    cast.original_name                  crew.original_name\n    cast.popularity                     crew.popularity\n    cast.profile_path                   crew.profile_path\n    cast.cast_id                        crew.credit_id\n    cast.character                      crew.department\n    cast.credit_id                      crew.job\n    cast.order                          tmdb_id\n    tmdb_id\n```\n\n## For Developers\n\nThe movieparse object exposes the following methods and attributes:\n\n`moviesyms.parse()`\n\n1. It saves all directories inside root_movie_dir in the mapping dataframe.\n2. Mapping is appended to the cached_mapping which was created during initialization. User-supplied tmdb_id_mans are kept while duplicate paths are dropped.\n3. Title and possibly year are extracted from each folder name and the TMDB API is queried for getting the TMDB ID, which is appended in mapping. Mapping.csv gets written.\n4. A set of tmdb_ids and tmdb_id_mans is created for looking up the metadata (cached tmdb_ids are excluded if specified).\n5. Metadata is looked up from the newly created set.\n\n`moviesyms.write()`\n\n- Writes all non-empty metadata tables to output_path destination.\n\nMapping:\n\n- `moviesyms.mapping`\n\nMetadata dataframes:\n\n- `moviesyms.cast`\n- `moviesyms.collect`\n- `moviesyms.crew`\n- `moviesyms.details`\n- `moviesyms.genres`\n- `moviesyms.prod_comp`\n- `moviesyms.prod_count`\n- `moviesyms.spoken_langs`\n\nCaches:\n\n- `moviesyms.cached_metadata_ids`\n- `moviesyms.cached_ids`\n- `moviesyms.cached_mapping`\n',
    'author': 'schuenemann',
    'author_email': 'None',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/tilschuenemann/movieparse',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
