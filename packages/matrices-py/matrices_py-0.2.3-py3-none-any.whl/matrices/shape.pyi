from collections.abc import Collection, Iterator
from typing import Any, Literal, Optional, SupportsIndex, TypeVar, final

from .rule import Rule

__all__ = ["Shape"]

Self = TypeVar("Self")


@final
class Shape(Collection[int]):

    __slots__: tuple[Literal["data"]]
    __match_args__: tuple[Literal["nrows"], Literal["ncols"]]

    def __init__(self: Self, nrows: int = 0, ncols: int = 0) -> None: ...
    def __repr__(self: Self) -> str: ...
    def __str__(self: Self) -> str: ...
    def __eq__(self: Self, other: Any) -> bool: ...
    def __ne__(self: Self, other: Any) -> bool: ...
    def __len__(self: Self) -> Literal[2]: ...
    def __getitem__(self: Self, key: SupportsIndex) -> int: ...
    def __setitem__(self: Self, key: SupportsIndex, value: int) -> None: ...
    def __iter__(self: Self) -> Iterator[int]: ...
    def __reversed__(self: Self) -> Iterator[int]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    def __copy__(self: Self) -> Shape: ...
    def __deepcopy__(self: Self, memo: Optional[dict[int, Any]] = None) -> Shape: ...

    @property
    def data(self: Self) -> list[int]: ...
    @property
    def nrows(self: Self) -> int: ...
    @nrows.setter
    def nrows(self: Self, value: int) -> None: ...
    @property
    def ncols(self: Self) -> int: ...
    @ncols.setter
    def ncols(self: Self, value: int) -> None: ...

    def copy(self: Self) -> Shape: ...
    def reverse(self: Self) -> Shape: ...
    def subshape(self: Self, *, by: Rule = Rule.ROW) -> Shape: ...
    def resolve_index(self: Self, key: SupportsIndex, *, by: Rule = Rule.ROW) -> int: ...
    def resolve_slice(self: Self, key: slice, *, by: Rule = Rule.ROW) -> range: ...
    def sequence(self: Self, index: int, *, by: Rule = Rule.ROW) -> tuple[int, int, int]: ...
    def range(self: Self, index: int, *, by: Rule = Rule.ROW) -> range: ...
    def slice(self: Self, index: int, *, by: Rule = Rule.ROW) -> slice: ...
