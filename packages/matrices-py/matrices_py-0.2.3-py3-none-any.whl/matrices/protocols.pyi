from abc import abstractmethod
from collections.abc import Iterator
from typing import Any, Literal, Protocol, TypeVar, overload, runtime_checkable

from .rule import Rule

__all__ = [
    "ComplexLike",
    "RealLike",
    "IntegralLike",
    "ShapeLike",
    "MatrixLike",
    "ComplexMatrixLike",
    "RealMatrixLike",
    "IntegralMatrixLike",
]

T_co = TypeVar("T_co", covariant=True)
ComplexLikeT_co = TypeVar("ComplexLikeT_co", bound=ComplexLike, covariant=True)
RealLikeT_co = TypeVar("RealLikeT_co", bound=RealLike, covariant=True)
IntegralLikeT_co = TypeVar("IntegralLikeT_co", bound=IntegralLike, covariant=True)

Self = TypeVar("Self")


@runtime_checkable
class ComplexLike(Protocol):

    @abstractmethod
    def __eq__(self: Self, other: Any) -> bool: ...

    @abstractmethod
    def __add__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __radd__(self: Self, other: Any) -> Any: ...
    def __sub__(self: Self, other: Any) -> Any: ...
    def __rsub__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __mul__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rmul__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __truediv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rtruediv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __pow__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rpow__(self: Self, other: Any) -> Any: ...

    @abstractmethod
    def __neg__(self: Self) -> ComplexLike: ...
    @abstractmethod
    def __pos__(self: Self) -> ComplexLike: ...
    @abstractmethod
    def __abs__(self: Self) -> RealLike: ...

    @abstractmethod
    def conjugate(self: Self) -> ComplexLike: ...


@runtime_checkable
class RealLike(ComplexLike, Protocol):

    @abstractmethod
    def __lt__(self: Self, other: Any) -> bool: ...
    @abstractmethod
    def __le__(self: Self, other: Any) -> bool: ...

    @abstractmethod
    def __floordiv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rfloordiv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __mod__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rmod__(self: Self, other: Any) -> Any: ...

    @abstractmethod
    def __neg__(self: Self) -> RealLike: ...
    @abstractmethod
    def __pos__(self: Self) -> RealLike: ...
    @abstractmethod
    def __abs__(self: Self) -> RealLike: ...

    @abstractmethod
    def conjugate(self: Self) -> RealLike: ...


@runtime_checkable
class IntegralLike(RealLike, Protocol):

    @abstractmethod
    def __neg__(self: Self) -> IntegralLike: ...
    @abstractmethod
    def __pos__(self: Self) -> IntegralLike: ...
    @abstractmethod
    def __abs__(self: Self) -> IntegralLike: ...

    @abstractmethod
    def __index__(self: Self) -> int: ...

    @abstractmethod
    def conjugate(self: Self) -> IntegralLike: ...


@runtime_checkable
class ShapeLike(Protocol):

    def __eq__(self, other: Any) -> bool: ...

    def __len__(self: Self) -> Literal[2]: ...
    @abstractmethod
    def __getitem__(self: Self, key: int) -> int: ...
    def __iter__(self: Self) -> Iterator[int]: ...
    def __reversed__(self: Self) -> Iterator[int]: ...
    def __contains__(self: Self, value: Any) -> bool: ...

    @property
    def nrows(self: Self) -> int: ...
    @property
    def ncols(self: Self) -> int: ...


@runtime_checkable
class MatrixLike(Protocol[T_co]):

    @abstractmethod
    def __eq__(self: Self, other: Any) -> bool: ...

    def __len__(self: Self) -> int: ...
    @abstractmethod
    @overload
    def __getitem__(self: Self, key: int) -> T_co: ...
    @abstractmethod
    @overload
    def __getitem__(self: Self, key: slice) -> Self: ...
    @abstractmethod
    @overload
    def __getitem__(self: Self, key: tuple[int, int]) -> T_co: ...
    @abstractmethod
    @overload
    def __getitem__(self: Self, key: tuple[int, slice]) -> Self: ...
    @abstractmethod
    @overload
    def __getitem__(self: Self, key: tuple[slice, int]) -> Self: ...
    @abstractmethod
    @overload
    def __getitem__(self: Self, key: tuple[slice, slice]) -> Self: ...
    def __iter__(self: Self) -> Iterator[T_co]: ...
    def __reversed__(self: Self) -> Iterator[T_co]: ...
    def __contains__(self: Self, value: Any) -> bool: ...
    @abstractmethod
    def __copy__(self: Self) -> Self: ...

    @abstractmethod
    def __and__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rand__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __or__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __ror__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __xor__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rxor__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __invert__(self: Self) -> Any: ...

    @property
    @abstractmethod
    def shape(self: Self) -> ShapeLike: ...
    @property
    def nrows(self: Self) -> int: ...
    @property
    def ncols(self: Self) -> int: ...
    @property
    def size(self: Self) -> int: ...

    @abstractmethod
    def eq(self: Self, other: Any) -> IntegralMatrixLike[bool]: ...
    @abstractmethod
    def ne(self: Self, other: Any) -> IntegralMatrixLike[bool]: ...
    @abstractmethod
    def slices(self: Self, *, by: Rule = Rule.ROW) -> Iterator[Self]: ...
    def copy(self: Self) -> Self: ...


@runtime_checkable
class ComplexMatrixLike(MatrixLike[ComplexLikeT_co], Protocol[ComplexLikeT_co]):

    @abstractmethod
    def __add__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __radd__(self: Self, other: Any) -> Any: ...
    def __sub__(self: Self, other: Any) -> Any: ...
    def __rsub__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __mul__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rmul__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __truediv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rtruediv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __pow__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rpow__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __matmul__(self: Self, other: Any) -> Any: ...

    @abstractmethod
    def __neg__(self: Self) -> ComplexMatrixLike: ...
    @abstractmethod
    def __pos__(self: Self) -> ComplexMatrixLike: ...
    @abstractmethod
    def __abs__(self: Self) -> RealMatrixLike: ...

    @abstractmethod
    def conjugate(self: Self) -> ComplexMatrixLike: ...
    @abstractmethod
    def complex(self: Self) -> ComplexMatrixLike[complex]: ...


@runtime_checkable
class RealMatrixLike(ComplexMatrixLike[RealLikeT_co], Protocol[RealLikeT_co]):

    @abstractmethod
    def __lt__(self: Self, other: Any) -> bool: ...
    @abstractmethod
    def __le__(self: Self, other: Any) -> bool: ...
    @abstractmethod
    def __gt__(self: Self, other: Any) -> bool: ...
    @abstractmethod
    def __ge__(self: Self, other: Any) -> bool: ...

    @abstractmethod
    def __floordiv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rfloordiv__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __mod__(self: Self, other: Any) -> Any: ...
    @abstractmethod
    def __rmod__(self: Self, other: Any) -> Any: ...

    @abstractmethod
    def __neg__(self: Self) -> RealMatrixLike: ...
    @abstractmethod
    def __pos__(self: Self) -> RealMatrixLike: ...
    @abstractmethod
    def __abs__(self: Self) -> RealMatrixLike: ...

    @abstractmethod
    def lt(self: Self, other: Any) -> IntegralMatrixLike[bool]: ...
    @abstractmethod
    def le(self: Self, other: Any) -> IntegralMatrixLike[bool]: ...
    @abstractmethod
    def gt(self: Self, other: Any) -> IntegralMatrixLike[bool]: ...
    @abstractmethod
    def ge(self: Self, other: Any) -> IntegralMatrixLike[bool]: ...

    @abstractmethod
    def conjugate(self: Self) -> RealMatrixLike: ...
    @abstractmethod
    def float(self: Self) -> RealMatrixLike[float]: ...


@runtime_checkable
class IntegralMatrixLike(RealMatrixLike[IntegralLikeT_co], Protocol[IntegralLikeT_co]):

    @abstractmethod
    def __neg__(self: Self) -> IntegralMatrixLike: ...
    @abstractmethod
    def __pos__(self: Self) -> IntegralMatrixLike: ...
    @abstractmethod
    def __abs__(self: Self) -> IntegralMatrixLike: ...

    @abstractmethod
    def __index__(self: Self) -> int: ...

    @abstractmethod
    def conjugate(self: Self) -> IntegralMatrixLike: ...
    @abstractmethod
    def int(self: Self) -> IntegralMatrixLike[int]: ...
