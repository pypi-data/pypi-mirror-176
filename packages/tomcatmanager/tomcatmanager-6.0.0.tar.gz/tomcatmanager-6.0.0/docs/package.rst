Use from Python
===============


Connect to the server
---------------------

Before you can do anything useful, you need to create a `TomcatManager` object
and connect to a server.

.. automethod:: tomcatmanager.tomcat_manager.TomcatManager.connect
   :noindex:


Responses from the server
-------------------------

All the methods of :class:`.TomcatManager` which interact with the server
return a response in the form of a :class:`.TomcatManagerResponse` object.
Use this object to check whether the command completed successfully, and to
get any results generated by the command.

.. autoclass:: tomcatmanager.models.TomcatManagerResponse
   :members:
   :noindex:


Managing Applications
---------------------

This library provides a robust API to manage applications in a tomcat server.
The following methods are available:

- :meth:`.TomcatManager.list` - return a list of all installed applications
- :meth:`.TomcatManager.deploy_localwar` - deploy a warfile on the local
  filesystem to the Tomcat server
- :meth:`.TomcatManager.deploy_serverwar` - deploy a war file from the server
  filesystem to the Tomcat server
- :meth:`.TomcatManager.deploy_servercontext` - deploy an application defined by a
  context file from the server filesystem to the Tomcat server
- :meth:`.TomcatManager.undeploy` - undeploy an application in the Tomcat server
- :meth:`.TomcatManager.start` - start an application already deployed in the
  Tomcat server
- :meth:`.TomcatManager.stop` - stop an application already deployed in the
  Tomcat server
- :meth:`.TomcatManager.reload` - stop and start a tomcat application
- :meth:`.TomcatManager.sessions` - get the age of the sessions for an application.
- :meth:`.TomcatManager.expire` - expire idle sessions


Parallel Deployment
-------------------

Tomcat supports a `parallel deployment feature
<https://tomcat.apache.org/tomcat-8.5-doc/config/context.html#Parallel_deplo
yment>`_ which allows multiple versions of the same WAR to be deployed
simultaneously at the same URL. To utilize this feature, you need to deploy an
application with a version string. The combination of path and version string
uniquely identify the application::

   >>> tomcat = getfixture("tomcat")
   >>> safe_path = getfixture("safe_path")
   >>> localwar_file = getfixture("localwar_file")
   >>> with open(localwar_file, "rb") as localwar_fileobj:
   ...     r = tomcat.deploy_localwar(safe_path, localwar_fileobj, version="42")
   ...     r.ok
   True
   >>> with open(localwar_file, "rb") as localwar_fileobj:
   ...     r = tomcat.deploy_localwar(safe_path, localwar_fileobj, version="43")
   ...     r.ok
   True

We now have two instances of the same application, deployed at the same
location, but with different version strings. To do anything to either of those
applications, you must supply both the path and the version string::

   >>> r = tomcat.stop(path=safe_path, version="42")
   >>> r.ok
   True
   >>> r = tomcat.undeploy(path=safe_path, version="42")
   >>> r.ok
   True
   >>> r = tomcat.undeploy(path=safe_path, version="43")
   >>> r.ok
   True

The following methods include an optional version parameter to support parallel
deployments:

- :meth:`~.TomcatManager.deploy_localwar`
- :meth:`~.TomcatManager.deploy_serverwar`
- :meth:`~.TomcatManager.deploy_servercontext`
- :meth:`~.TomcatManager.undeploy`
- :meth:`~.TomcatManager.start`
- :meth:`~.TomcatManager.stop`
- :meth:`~.TomcatManager.reload`
- :meth:`~.TomcatManager.sessions`
- :meth:`~.TomcatManager.expire`


Information about Tomcat
------------------------

There are a number of methods which just return information about the Tomcat
server. With the exception of :meth:`.TomcatManager.find_leakers` (which
triggers garbage collection), these methods don't effect any change on the
server.

- :meth:`.TomcatManager.find_leakers` - find applications that are leaking memory
- :meth:`.TomcatManager.resources` - get global JNDI resources
- :meth:`.TomcatManager.server_info` - get information about the tomcat server
- :meth:`.TomcatManager.status_xml` - get server status information in xml format
- :meth:`.TomcatManager.thread_dump` - get a jvm thread dump
- :meth:`.TomcatManager.vm_info` - get diagnostic information about the jvm


SSL/TLS
-------

Tomcat servers can be configured to serve their applications over SSL/TLS.
This library includes a few related methods:

- :meth:`.TomcatManager.ssl_connector_ciphers` - get SSL/TLS ciphers for eac
  connector
- :meth:`.TomcatManager.ssl_connector_certs` - get the certificate chain for
  each virtual host
- :meth:`.TomcatManager.ssl_connector_trusted_certs` - get the trusted certificates
  for each virtual host
- :meth:`.TomcatManager.ssl_reload` - reload certificates and keys

The :meth:`.TomcatManager.ssl_reload` is the only one of these methods that
causes the server to take any action, the rest are informational only.


Differences in Tomcat Versions
------------------------------

Not every version of Tomcat supports all of the methods in this library. If
you call a method that is not implemented by the particular server you are
connected to, :exc:`~.models.TomcatNotImplementedError` will be raised.

If you prefer to check whether a method is supported before calling it, you
can do so using :meth:`.TomcatManager.implements`:

   >>> tomcat = getfixture("tomcat")
   >>> if tomcat.implements(tomcat.list):
   ...     print("list is implemented")
   ... else:
   ...     print("list is not implemented")
   list is implemented

If you call :meth:`.TomcatManager.implements` and are not connected to a
server, :exc:`~.models.TomcatNotConnected` will be raised.

There is a way to check whether a method is supported without connecting
to a server. You must specify the version of the Tomcat server and the
method you want to check is implemented. Use one of the values in the enumeration
:class:`~.models.TomcatMajorMinor` to specify the version of Tomcat you
want to check::

   >>> import tomcatmanager as tm
   >>> tomcat = tm.TomcatManager()
   >>> tver = tm.TomcatMajorMinor.V8_5
   >>> print(tomcat.implemented_by(tomcat.ssl_reload, tver))
   True


Specifying As A Dependency
--------------------------

If you incorporate tomcatmanager into your own package, you will need to specify it as
a dependency. I strongly recommend you specify the dependency such that it limits
usage to a single major version of this library. This way when a new major version of
this library is released, it won't break your code. If you use ``setup.py``, you
should do it like this::

   setup(
   ...
       install_requires=["tomcatmanager>=3,<4"]
   ...
   )

When this library adds support for a new version of Tomcat or Python, we increment the
minor version number. However, if support for these new versions requires API changes
incompatible with prior releases of this software, then we increment the major version
number.

When this library drops support for a version of Tomcat or Python, we increment the
major version number. For example, when this project dropped support for Python 3.6,
we released that version as 5.0.0 instead of 4.1.0, even though there were no
incompatible API changes.

These versioning rules were chosen so that if you are using this library against a
single version of Tomcat, and you specify your dependency rules as suggested above,
you will not have to worry about a future release of this software breaking your
setup.
