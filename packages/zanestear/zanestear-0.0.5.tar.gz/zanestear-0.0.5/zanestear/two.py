'''
1.1
def function1(x):
 a=x
 b=(a+1)**0.5
 c=a**0.5
 d=a*(b-c)
 print("\n")
 print(d)
 return d
num1=int(input("输入参数\n"))
function1(num1)
print("-"*50)
print(function1(1)-0.414213562)
#精确值 0.414213562

def function2(x):
 a=x
 b=(a+1)**0.5
 c=a**0.5
 d=b+c
 e=1/d
 f=a*e
 return f
a=10**10
print(function2(a))
#精确值 50000

答案：
1.（1）
0.414213562
0.414213562
1.（2）
49999.9442
50000
'''


'''
1.2
import math
import numpy as np
def jifen(n):
 start = 0
 stop = 1
 length = 1000
 x = np.linspace(start, stop, length)
 y = (x**n)/(x+5)
 result = sum(y*(stop-start)/length)
 return result
a=jifen(1)
print(a)
print(math.log(1.2))
print("-"*50)
c=[]
c.append(jifen(0))
for i in range(1,21):
 a=i
 b=jifen(i)
 c.append(b)
 print('I '+str(a)+" 的积分为："+str(b))
print("--"*50)
for i in range(1,20):
 b=-5*c[i-1]+1/i
 print("经过递推公式运算 I "+str(i)+" 的积分为："+str(b))
 
 
 #include <stdio.h>
#include <stdlib.h>
#include <math.h>
int n;
double jifen(double x)
{
 scanf("%d",&n);//请输入 n 值
 return pow(x,n)/(x+5);
}
double jifenjianyi(double x)
{
 return pow(x,(n-1))/(x+5);
}
double in(double(*fun)(double x),double a,double b,int step)
{
 double s,h;
 int i;
 s = 0.0;
 h = (b-a)/step;
 for(i=0;i<step;i++){
 s = s + ((fun(a+i*h)+fun(a+(i+1)*h))*h)/2;
 }
 return s;
}
int main()
{
 double y,yjianyi,i0;
 i0 = log(1.2);
 //printf("%.10f\n",i0);//y0=0.1823215823
 y = in(jifen,0.0,1.0,200);//n 越大，分得越精细，结果越准确
 yjianyi = in(jifenjianyi,0.0,1.0,200);
 printf("In 的值为：%.10f\n",y);
 printf("In-1 的值为：%.10f\n",yjianyi);
 printf("递推等式右边的值为：%.10f\n",-5*yjianyi+1/n);
 return 0;
}

 
 答案：
 2.
I1 的值为 0.0883922
I2 的值为 0.0580389
I3 的值为 0.0431387
I4 的值为 0.0343063
I5 的值为 0.0284684
I6 的值为 0.0243249
I7 的值为 0.0212326
I8 的值为 0.0188369
I9 的值为 0.0169265
I10 的值为 0.0153676
I11 的值为 0.0140713
I12 的值为 0.0129766
I13 的值为 0.0120399
I14 的值为 0.0112289
I15 的值为 0.0105219
I16 的值为 0.00989032
I17 的值为 0.00937191
I18 的值为 0.00869602
I19 的值为 0.00840703
I20 的值为 0.00800440
 '''


'''
二分法：
#include <stdio.h>
#include <stdlib.h>
double f(double x)
{
 double ans;
 ans = x*x*x+4*x*x-10;
 return ans;
}
int main()
{
 float a,b,ep,temp;
 a =1;
 b=2;
 ep = 0.00025;
 while ((b-a)>=ep)
 {
 temp = (a+b)/2;
 if (f(a)*f(temp)>0)
 {
 a = temp;
 printf("%f\n",a);
 }
 else
 {
 b = temp;
 printf("%f\n",b);
 }
 }
 printf("得到的根为:%f\n",temp);
 return 0;
}

1.2.2
s1 = []
s2 = []
s3 = []
n = 10
for i in range(n):
 x = f1(x)
 s1.append(x)
for i in range(n):
 y = f2(y)
 s2.append(y)
for i in range(n):
 z = f3(z)
s3.append(z)
plt.plot(s1, c='blue', marker='o', linestyle=':', label='f1')
plt.plot(s2, c='red', marker='*', linestyle='-', label='f2')
plt.plot(s3, c='green', marker='+', linestyle='--', label='f3')
font1 = {'family': 'Times New Roman', 'weight': 'normal', 'size': 10}
plt.xticks(fontproperties='Times New Roman', fontsize=10)
plt.yticks(fontproperties='Times New Roman', fontsize=10)
plt.xlabel(u'The number of iterations', font1)
plt.ylabel(u'The value of the xn', font1)
plt.legend(loc=4, prop=font1)
x_major_locator = MultipleLocator(1)
ax = plt.gca()
ax.xaxis.set_major_locator(x_major_locator)
plt.show()

import numpy as np
from matplotlib import pyplot as plt
def f(x,a):
 return x**2 - a
def fdao(x):
 return 2*x
a = int(input('请输入要求平方根的正实数：'))
x0 = int(input('请输入一个初值：'))
start = x0
ep = 0.00001
step = int(input('请输入期望的迭代次数：'))
k=1
x1 = x0-f(x0,a)/fdao(x0)
print(f'第 1 次迭代的结果为{x1}')
x = list(np.arange(-5,5.5,0.5))
y = []
for i in range(len(x)):
 y.append(f(x[i],a))
result =[]
y0 = []
result.append(x1)
y0.append(0)
while abs(x1-x0)>ep or k<step:
 x0 = x1
 x1 = x1-f(x1,a)/fdao(x1)
 k = k+1
 result.append(x1)
 y0.append(0)
 print(f'第{k}次迭代的结果为{x1}')
plt.plot(x,y)
plt.scatter(result,y0,marker='o',color = 'red')
plt.title(f'Newton\'s method, a={a}, X0={start}, step={step}')
plt.grid(True)
plt.show()



答案
1.1
1.500000
1.250000
1.375000
1.312500
1.343750
1.359375
1.367188
1.363281
1.365234
1.364258
1.364746
1.364990
得到的根
为:1.3650
1.2
请输入初值:2
请输入迭代次数：10
第 1 次得到的根为:3.0000
第 2 次得到的根为:8.0000
第 3 次得到的根为:63.0000
第 4 次得到的根为:3968.0000
第 5 次得到的根为:15745023.0000
第 6 次得到的根为:247905749270528.0000
第 7 次得到的根为:61457260521381896000000000000.0000
第 8 次得到的根为:3776994870793006000000000000000000000000000000000000000000
第 9 次得到的根为: 1426569025399667600000000000000000000000000000000000000000
第 10 次得到的根为:203509918422975730000000000000000000000000000000000000000
----------------------------------------------------------------------------------------------------------------
第 1 次得到的根为:1.5000
第 2 次得到的根为:1.6667
第 3 次得到的根为:1.6000
第 4 次得到的根为:1.6250
第 5 次得到的根为:1.6154
第 6 次得到的根为:1.6190
第 7 次得到的根为:1.6176
第 8 次得到的根为:1.6182
第 9 次得到的根为:1.6180
第10次得到的根为:1.6181
----------------------------------
----------------------------------
第 1 次得到的根为:1.7321
第 2 次得到的根为:1.6529
第 3 次得到的根为:1.6288
第 4 次得到的根为:1.6213
第 5 次得到的根为:1.6191
第 6 次得到的根为:1.6184
第 7 次得到的根为:1.6181
第 8 次得到的根为:1.6181
第 9 次得到的根为:1.6180
第10次得到的根为:1.6180
（除了 X0=1 之外，其他的
初值产生的结果都大同小
异，就不在此列出其计算
结果了）
当初值为 1 时，f1 震荡，f2 与 f3
依旧收敛，生成图像如图所示。
1.3
请输入要求平方根的正实数：13
请输入一个初值：30
请输入期望的迭代次数：2
第 1 次迭代的结果为 15.2166666666
第 2 次迭代的结果为 8.03549653158
第 3 次迭代的结果为 4.82665907478
第 4 次迭代的结果为 3.76001673847
第 5 次迭代的结果为 3.60872407773
第 6 次迭代的结果为 3.60555267023
第 7 次迭代的结果为 3.60555127546

'''

'''
答案
1.初始向量X(0)=[0,0,……0], b=[1,1,……1]
雅可比
第1次迭代的值为：[[0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333], [0.3333333333333333]]
第2次迭代的值为：[[0.4166666666666667], [0.47222222222222227], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.5], [0.47222222222222227], [0.3611111111111111]]

……

第15次迭代的值为：[[0.48163228854903645], [0.5734085305735673], [0.6327924011063587], [0.6520903470694123], [0.6609319616627539], [0.6642939488872621], [0.66570171014508], [0.6662589180568524], [0.6664799898567842], [0.6665526202623702], [0.6665416961818308], [0.6664372932724828], [0.6661481026245619], [0.6654201625206481], [0.6636206138893159], [0.6591601376526329], [0.6482222957247253], [0.6208878489809101], [0.5550097566872669], [0.38507336430884603]]
第16次迭代的值为：[[0.4816341218544578], [0.5734116438650169], [0.6327968337914791], [0.6520959337499211], [0.6609385585970656], [0.6643013840618278], [0.6657098071173139], [0.6662674974294468], [0.6664888735804463], [0.6665616319505472], [0.6665506599625877], [0.6664460316996503], [0.6661564351381174], [0.665427905329406], [0.6636275832246541], [0.6591661525608034], [0.6482271953203057], [0.6208914672321221], [0.5550120601920198], [0.38507398741507587]]

高斯赛德尔
第1次迭代的值为：[[0.3333333333333333], [0.3888888888888889], [0.4259259259259259], [0.43672839506172845], [0.4416152263374486], [0.4433299039780521], [0.44402291952446277], [0.4442813119189148], [0.4443821286135244], [0.44442046409549696], [0.4444352547337099], [0.4444409144635764], [0.44444309030507195], [0.4444439245894767], [0.4444442449570021], [0.44444436787529007], [0.4444444150589652], [0.4444444331661017], [0.44444444011593065], [0.3703703694305085]]
第2次迭代的值为：[[0.43364197530864196], [0.5129886831275721], [0.5645576131687243], [0.5807220221764975], [0.5880570320835239], [0.5907636031092821], [0.5918774158961202], [0.5923085963520057], [0.5924808992937364], [0.592548484905873], [0.5925752323614756], [0.5925857545690371], [0.5925899029696254], [0.5925915348581319], [0.5925921769579529], [0.5925924293381725], [0.5925925285068693], [0.5864197280011901], [0.5421810602808556], [0.3822016440000992]]

……

第10次迭代的值为：[[0.4816288042635406], [0.5734056195046594], [0.6327908530853957], [0.6520906053674969], [0.660934119411254], [0.6642980062919204], [0.6657076702099228], [0.6662667920540231], [0.6664897338118446], [0.6665640576576015], [0.6665544837353093], [0.6664509412508935], [0.6661620283764537], [0.6654337508263521], [0.6636332691977361], [0.6591713146484215], [0.6482315394897237], [0.6208947417843522], [0.5550141726413225], [0.38507456181536265]]
第11次迭代的值为：[[0.48163350767455954], [0.5734116105739506], [0.6327976715807258], [0.6520977665708192], [0.6609414072930105], [0.6643052261358924], [0.6657145981237238], [0.6662731623053859], [0.666495293482084], [0.6665686381659222], [0.6665580400576808], [0.666453543821712], [0.6661638248792954], [0.6654349205520164], [0.6636339862308246], [0.659171726148122], [0.648231757894758], [0.6208948457529705], [0.5550142144192853], [0.38507457047941424]]

初始向量X(0)=[1,1,……1], b=[2,2,……2]
雅可比
第1次迭代的值为：[[0.9166666666666666], [1.0833333333333333], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.1666666666666667], [1.0833333333333333], [0.75]]
第2次迭代的值为：[[0.9444444444444443], [1.1111111111111112], [1.2152777777777777], [1.2430555555555556], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.25], [1.2430555555555556], [1.2013888888888888], [1.0833333333333333], [0.7638888888888888]]

……

第14次迭代的值为：[[0.9632683676075738], [1.146823490757973], [1.265593942656097], [1.3041921917304578], [1.3218774706325087], [1.328603132829032], [1.3314199777662388], [1.3325353510506999], [1.332978096090369], [1.3331236102356057], [1.333101670275806], [1.3328924232882038], [1.3323132413331984], [1.3308561884640044], [1.3272555396972592], [1.3183326562617186], [1.2964546986311134], [1.241783175236577], [1.1100242801404518], [0.7701480187806213]]
第15次迭代的值为：[[0.9632700770143369], [1.1468264010214833], [1.2655981002680787], [1.3041974541803514], [1.321883714128443], [1.328610203298221], [1.3314277112068618], [1.3325435742314877], [1.3329866308845546], [1.3331322755892712], [1.333110283705932], [1.332900801826468], [1.33232120278979], [1.3308635534675697], [1.3272621357846464], [1.3183383200297774], [1.2964592902361918], [1.241786552715456], [1.1100264238887925], [0.7701485979363815]]

高斯赛德尔
第1次迭代的值为：[[0.9166666666666666], [1.0694444444444444], [1.1712962962962963], [1.2010030864197532], [1.2144418724279835], [1.2191572359396432], [1.2210630286922723], [1.2217736077770158], [1.2220508536871921], [1.2221562762626166], [1.222196950517702], [1.222212514774835], [1.2222184983389477], [1.2222207926210609], [1.2222216736317557], [1.2222220116570477], [1.2222221414121544], [1.2222221912067797], [1.1388888769854761], [0.7685185159338982]]
第2次迭代的值为：[[0.9425154320987654], [1.1190522119341564], [1.2330889917695473], [1.2694392646890718], [1.2859454184766042], [1.2921024805669867], [1.2946457040709836], [1.2956376560288296], [1.2960358765976314], [1.2961929854195278], [1.2962554479437756], [1.2962801392171694], [1.2962899154376661], [1.296293777417755], [1.2962953029166187], [1.2962959047735068], [1.2893516976552222], [1.2434412974990667], [1.1094392770434294], [0.7702867747915888]]

……

第10次迭代的值为：[[0.9632681985846318], [1.1468247265826488], [1.2655970572576727], [1.3041973422715274], [1.32188468277191], [1.32861235675324], [1.3314311013545679], [1.3325481619537278], [1.332992266011629], [1.3331387158893684], [1.3331172347203981], [1.3329079544364288], [1.3323282598335078], [1.3308702441051306], [1.3272682220596324], [1.3183435965450578], [1.296463592680032], [1.2417897281862273], [1.1100284435830678], [0.7701491440155189]]
第11次迭代的值为：[[0.9632705425352475], [1.1468277118214474], [1.2656004444577589], [1.3042008602528354], [1.321888164985373], [1.3286156295738705], [1.3314340011710166], [1.3325505733190444], [1.3329941511923533], [1.3331401082984147], [1.3331182113746292], [1.3329086079016517], [1.3323286781206523], [1.3308705004006065], [1.3272683720576677], [1.3183436798385195], [1.2964636359741857], [1.2417897485807121], [1.1100284517638872], [0.7701491457150594]]


2.	初始向量X(0)=[0,0,……0], b=[1,1,……1]，主对角线元素为3时
雅可比迭代次数为16
高斯赛德尔迭代次数为11
初始向量X(0)=[0,0,……0], b=[1,1,……1]，主对角线元素为6时
雅可比迭代次数为9
高斯赛德尔迭代次数为7
初始向量X(0)=[0,0,……0], b=[1,1,……1]，主对角线元素为9时
雅可比迭代次数为7
高斯赛德尔迭代次数为6

3.	拉格朗日插值
计算结果为：
0.19936817528988982
线性插值计算误差为：
7.265467980462133e-06
抛物插值计算误差为：
3.2618102759432574e-07

'''

'''
1.拉格朗日插值法的实验
1. import math
2. get_ipython().run_line_magic('matplotlib', 'inline')
3. # In[2]:
4. import numpy as np
5. # In[5]:
6. import matplotlib.pyplot as plt
7. from pylab import mpl
8. import pandas as pd
9.
10. def chazhi(a):
11. x = 11
12. y = 12
13. z = 13
14. l = 0.190809
15. m = 0.207912
16. n = 0.224951
17. l1=((a-y)*(a-z))/((x-y)*(x-z))
18. l2=((a-x)*(a-z))/((y-x)*(y-z))
19. l3=((a-x)*(a-y))/((z-x)*(z-y))
20. result = l*l1 + m*l2 + n*l3
21. return result
22.
23. a=11.5
24. b=chazhi(a)
25. X=[11,12,13]
26. Y=[0.190809,0.207912,0.224951]
27.
28. xs=np.linspace(11,13,3000,endpoint=True)
29. ys=chazhi(np.linspace(11,13,3000,endpoint=True))
30. mpl.rcParams['font.sans-serif'] = ['SimHei']
31. mpl.rcParams['axes.unicode_minus'] = False
32. plt.title("拉格朗日插值法")
33. plt.plot(X,Y,'s',label="原先值")#蓝点表示原来的值
34. plt.plot(xs,ys,'r',label='插入值拟合曲线')#插值曲线
35. plt.text(11.5,b,(11.5,b),color='r')
36. plt.plot(11.5,b,'s',label=" 插入值")#蓝点表示原来的值
37. plt.xlabel('x 轴')
38. plt.ylabel('y 轴')
39. plt.legend(loc=2)#指定 legend 的位置右下角
2.牛顿插值法的实验
1. import matplotlib.pyplot as plt
2. from pylab import mpl
3. import numpy as np
4. import pandas as pd
5. import math
6.
7. %matplotlib inline
8.
9. def sinx(x):
10. return math.sin(x*math.pi/180)
11.
12.
13. def get_diff_table(X,Y):
14. """
15. 得到插商表
16. """
17. n=len(X)
18. A=np.zeros([n,n])
19.
20. for i in range(0,n):
21. A[i][0] = Y[i]#每行第一个元素不参与计算差商表
22.
23. for j in range(1,n):
24. for i in range(j,n):
25. A[i][j] = (A[i][j-1] - A[i-1][j-1])/(X[i]-X[i-j])
26. #二次循环，进行差商表的计算
27. print(A)
28. return A
29.
30.
31. def niudun(X,Y,x):
32. """
33. 计算 x 点的插值
34. """
35. sum=Y[0]
36. temp=np.zeros((len(X),len(X)))
37. #将第一行赋值
38. for i in range(0,len(X)):
39. temp[i,0]=Y[i]
40. temp_sum=1.0
41. for i in range(1,len(X)):
42. #x 的多项式
43. temp_sum=temp_sum*(x-X[i-1])
44. #计算均差
45. for j in range(i,len(X)):
46. temp[j,i]=(temp[j,i-1]-temp[j-1,i-1])/(X[j]-X[j-i])
47. sum+=temp_sum*temp[i,i]
48. return sum
49.
50. X = [11 ,12 ,13]
51. Y = [0.190809 ,0.207912 ,0.224951]
52.
53. A = get_diff_table(X,Y)
54. df = pd.DataFrame(A)
55. xs=np.linspace(11,13,1000,endpoint=True)
56.
57. ys=[]
58. x=11.5
59. zs=[]
60. z=niudun(X,Y,x)
61. for x in xs:
62. ys.append(niudun(X,Y,x))
63. for x in xs:
64. zs.append(sinx(x))
65. plt.title("牛顿插值法模拟曲线")
66. mpl.rcParams['font.sans-serif'] = ['SimHei']
67. mpl.rcParams['axes.unicode_minus'] = False
68. plt.plot(X,Y,'s',label="原值")#蓝点表示原来的值
69. plt.plot(11.5,z,'s',label="模拟值")#蓝点表示原来的值
70. plt.plot(xs,ys,'r',label='插值曲线')#插值曲线
71.
72. plt.xlabel('x 轴')
73. plt.ylabel('y 轴')
74. plt.legend(loc=2)#指定 legend 的位置右下角
四.数值输出结果
1.拉格朗日插值
计算结果为：
0.19936817528988982
线性插值计算误差为：
7.265467980462133e-06
抛物插值计算误差为：
3.2618102759432574e-07
2.牛顿插值法解决
计算结果为：
0.1993685
插值计算误差为：
5.655828028416909e-07

'''

'''
#高斯-勒让德求积公式
#高斯-勒让德求积公式
import math
from sympy import * x,t = symbols("x,t")
#积分区间
a = 1
b = 3
#需要求积的目标函数
def f(x):
return math.exp(x)*math.sin(x)
n = 7 #n 次多项式正交，n 越大精度越高
#勒让德多项式
def L(n):
df = diff((x ** 2 - 1) ** (n + 1), x, n + 1)
# Python 内置阶乘函数 factorial
L = 1 /2**(n+1)/factorial(n+1) * df
return L
#高斯点 x 求取
def Gauss_point(n):
x_k_list = solve(L(n)) #求得零点解集
return x_k_list
#求积系数 A
def A(x_k_list):
A_list = []
for x_k in x_k_list:
A = 2/(1-x_k**2)/(diff(L(n),x,1).subs(x,x_k))**2
A_list.append(A)
return A_list
result = 0
x_k_list = Gauss_point(n)
A_list = A(Gauss_point(n))
sum = len(A_list)
#区间变换
if a == -1 and b == 1:
for i in range(sum):
result += (A_list[i] * f(x_k_list[i])).evalf()
print(result)
#将求积公式中的区间(a,b)转换为[-1,1]
else:
for i in range(sum):
X = (b-a)/2 * x_k_list[i] + (a+b)/2 #区间变换
result += (b-a)/2 * (A_list[i] * f(X)).evalf()
print(result)
2.
import matplotlib.pyplot as plt
a = 1
b = 1.5
h = 0.1
k = 1
y_e = [k]
def f(x, y):
res = x**2+y*x**3
return res
# (b-a)/h -> 得到总共有多少个 数对
num = int((b - a) / h)
# 得到 x
x = [(a + i * h) for i in range(num)]
# 得到最后一个 x
x.append(b)
'''  '''欧拉法 # 得到 欧拉法 得到的 y
for x_i in x:
# res 即 y_i+1、此即 y_i+1 = y_i + h * f(x_i, y_i)
res = y_e[-1] + h * f(x_i, y_e[-1])
y_e.append(res)
#这里多了个元素 我们 pop 一下
y_e.pop()
'''  '''改进的欧拉法 # 创建一个 改进的欧拉法 列表
y_r = [k]
# 获得 改进的欧拉法 的 y 值, 因为总共有 num + 1 个元素
for i in range(num):
res = y_r[-1] + h * 0.5 * (f(x[i], y_r[-1]) + f(x[i + 1], y_e[i + 1]))
y_r.append(res)
# 绘制图像
plt.plot(x, y_e, label = 'Euler', color = 'green')
plt.plot(x, y_r, label = 'Improved Euler', color = 'orange')
plt.legend()
plt.title('Experimental Image')
plt.show()
3.
clc,clear;
syms x y %设置符号变量 x,y
f(x,y)=-y;
z(x) = -x*y+1%我们计算得出的方程，用于验算
df=f;
y0=1;%设 y0=0
a=0;%设起始点
b=1;%设终点
h=0.1;%设步长
[x1,y1]=FourLongkuta(df,y0,a,b,h);%用四阶龙格库塔法求解
figure
hold on
plot(a:h:b,y1,'r')
legend('龙格库塔法')
hold off
function [x1,y1]=FourLongkuta(df,y0,a,b,h)%从左到右依次为已知的导函
数，初始函数值，初始横坐标值，终止横坐标值，步长
n=floor((b-a)/h);%求解所需的总步长，floor 的用法是取一个小数的最小整数
值
y1(1)=y0;%赋值 y1(1)=y(t0),且数为双精度，这样以后计算的符号值都会转换
成双精度
x1=a:h:b;%设 xn 的值
for i=1:n
%龙格库塔方法进行数值求值
k1=double (df( x1(i),y1(i) ) ) ;%double 将符号值转为双精
度值可以提高运算速度
k2=double (df( x1(i)+h/2,y1(i)+k1*h/2 ) );
k3=double (df( x1(i)+h/2,y1(i)+k2*h/2 ) );
k4=double (df( x1(i)+h,y1(i)+k3*h ) );
y1(i+1)=y1(i)+h*(k1+2*k2+2*k3+k4)/6;
end
end
四. 数值结果
1.
10.9501703146855
'''