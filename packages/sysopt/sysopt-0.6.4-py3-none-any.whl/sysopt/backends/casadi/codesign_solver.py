"""Codesign collation problems implementation."""

import casadi
from typing import Union, Dict, Tuple, Optional
from dataclasses import dataclass
import numpy as np

from sysopt.problems.problem_data import Domain, ConstrainedFunctional, CodesignSolution, CollocationSolverOptions
from sysopt.backends.casadi.expression_graph import substitute
from sysopt.backends.casadi.variational_solver import get_collocation_matrices
from sysopt.symbolic import Variable, PiecewiseConstantSignal
from sysopt.backends.implementation_hooks import get_backend

backend = get_backend('casadi')


__all__ = []


class ConstantFactory:
    """Helper class to constant valued decision variables."""
    def __init__(self,
                 param_or_var: Variable,
                 lower_bound, upper_bound
                 ):
        self.symbol = casadi.MX.sym(param_or_var.name, *param_or_var.shape)
        self.lower_bound = lower_bound
        self.upper_bound = upper_bound

    def __call__(self, t):
        return self.symbol

    def finalise(self):
        return self.symbol, \
               self.lower_bound,\
               self.upper_bound, \
               self.initial_guess()

    def initial_guess(self):
        guess = max(self.lower_bound, min(0, self.upper_bound))
        return guess

    def output(self):
        return self.symbol


class PiecewiseConstantFactory:
    """Helper class to generate piecewise constants at the given frequency."""
    def __init__(self, signal: PiecewiseConstantSignal,
                 lower_bound,
                 upper_bound):
        self._shape = signal.shape
        self._name = signal.name
        self._frequency = signal.frequency
        # todo: check if they're the same shape
        self._vector = []
        self.lower = lower_bound
        self.upper = upper_bound

    def __call__(self, index):
        last = len(self._vector)
        while index >= last:
            new_symbol = casadi.MX.sym(f'{self._name}[{last}]', *self._shape)
            self._vector.append(new_symbol)
            last = len(self._vector)

        return self._vector[index]

    def regularisation_cost(self):
        factor = 1 / len(self._vector)
        return factor ** 2 * sum(
            (v2 - v1)**2
            for v2, v1 in zip(self._vector[1:], self._vector[:-1])
        )

    def finalise(self):
        x = casadi.vertcat(*self._vector)
        x_lower = np.repeat(self.lower, len(self._vector))
        x_upper = np.repeat(self.upper, len(self._vector))
        x_initial = np.repeat(self.initial_guess(), len(self._vector))

        return x, x_lower, x_upper, x_initial

    def initial_guess(self):
        if self.lower != -np.inf and self.upper != np.inf:
            return (self.upper + self.lower) / 2
        else:
            return max(min(0, self.upper), self.lower)

    def output(self):
        return casadi.vertcat(*self._vector)


class ParameterFactory:
    """Helper class for generating a parameter vector at a time point"""
    _factories = {
        PiecewiseConstantSignal: PiecewiseConstantFactory,
        Variable: ConstantFactory
    }

    """Wrapper for generate constants over time"""
    def __init__(self, parameters):
        self.factories = [
            self._factories[type(p)](p, *bounds)
            for p, bounds in parameters.items()
        ]

    def __call__(self, step):
        return casadi.vertcat(*[f(step) for f in self.factories])

    def regularisation_cost(self):
        cost = 0
        for factory in self.factories:
            try:
                cost += factory.regularisation_cost()
            except AttributeError:
                pass
        return cost

    def finalise(self):
        p = []
        p_min = []
        p_max = []
        p_0 = []
        for f in self.factories:
            pf, pf_min, pf_max, pf0 = f.finalise()
            if pf.shape != 0:
                p.append(pf)
                p_min.append(pf_min)
                p_max.append(pf_max)
                p_0.append(pf0)
        if p:
            result = (
                casadi.vertcat(*p),
                casadi.vertcat(*p_min),
                casadi.vertcat(*p_max),
                casadi.vertcat(*p_0)
            )

            for r in result[1:]:
                assert r.is_constant(), r
            return result
        else:
            return (
                casadi.MX.sym('p', 0),
                casadi.DM.zeros(0, 0),
                casadi.DM.zeros(0, 0),
                casadi.DM.zeros(0, 0)
            )

    def output_list(self):
        return [factory.output() for factory in self.factories]


class StateFactory:
    """Helper factory to generate collated state variables.

    Notes:
        Initial conditions are generated by solving the underlying DAE at the
        given guess states.

    """

    def __init__(self, problem_data: 'CasadiCodesignProblemData',
                 options, p_guess):
        domain = problem_data.domain

        self.dim_x = domain.states
        self.dim_zu = domain.constraints + domain.inputs
        self._xz_0 = self._get_initial_conditions(
            problem_data, options, p_guess)

        self._xz = [
            (casadi.MX.sym(f'x_{i}', self.dim_x),
             casadi.MX.sym(f'z_{i}', self.dim_zu))
            for i in range(options.grid_size + 1)
        ]

        self._xz_colloc = {}

    @staticmethod
    def _get_initial_conditions(problem_data, options, p_guess):
        solver, args, _, _ = evaluate_problem(problem_data, options, p_guess)

        soln = solver(**args)

        xf = soln['xf'][1:, :]
        zf = soln['zf']

        xz = casadi.vertcat(xf, zf)
        return casadi.horzsplit(xz)

    def new_collocation_points(self, step, degree):
        xz = [(casadi.MX.sym(f'x_{step};{d}', self.dim_x),
               casadi.MX.sym(f'z_{step};{d}', self.dim_zu))
              for d in range(degree)]
        x, z = zip(*xz)
        self._xz_colloc[step] = xz
        return x, z

    def new_terminal(self, step):
        return self._xz[step]

    def finalise(self):
        variables = []
        x0 = []
        for i, (x, z) in enumerate(self._xz):
            variables += [x, z]
            x0.append(self._xz_0[i])
            if i + 1 == len(self._xz):
                break
            for xc, zc in self._xz_colloc[i]:
                variables += [xc, zc]
                x0.append(self._xz_0[i])

        x = casadi.vertcat(*variables)
        x0 = np.concatenate(x0)
        x_min = -np.inf * np.ones_like(x0)
        x_max = np.inf * np.ones_like(x0)
        return x, x_min, x_max, x0


# See https://coin-or.github.io/Ipopt/OPTIONS.html
ipopt_defaults = {
    'fixed_variable_treatment': 'make_constraint',
    'max_iter': 3000,
    'tol': 1e-6,

}


@backend.implements(CollocationSolverOptions)
def map_solver_options(options: CollocationSolverOptions):
    ipopt_options = ipopt_defaults.copy()
    if options.numerical_hessian:
        ipopt_options['hessian_approximation'] = 'limited-memory'
    if options.nlp_solver != 'ipopt':
        raise NotImplementedError(
            f'Solver {options.nlp_solver} not implemented'
        )
    ipopt_options.update(options.nlp_options)

    return CasadiSolverOptions(
        polynomial_degree=options.polynomial_degree,
        grid_size=100,
        solver=options.nlp_solver,
        solver_options=ipopt_options,
        constraint_tolerance=options.constraint_tolerance
    )


@dataclass
class CasadiSolverOptions:
    polynomial_degree: int = 4
    grid_size: int = 100
    solver: str = 'ipopt'
    solver_options: Optional[Dict] = None
    constraint_tolerance:float = 1e-4


@dataclass
class CasadiCodesignProblemData:
    """Container class for the casadi-fied codesign problem"""

    domain: Domain
    """Shape of the dynamical system to be optimised"""

    vector_field: casadi.Function
    """Function of s, x, zu, p -> dx/ds"""

    outputs: casadi.Function
    """Function of s, x, zu, p-> y"""

    final_time: casadi.Function
    """Function p -> T"""

    algebraic_constraint: casadi.Function
    """Function of s, x, zu, p-> 0"""

    quadrature: casadi.Function
    """Function of s, y, p -> dq/ds"""

    initial_conditions: casadi.Function
    """Function p -> x(0)"""

    cost_function: casadi.Function
    """Function of T(1), y[1], q[1] p"""

    parameters: Dict[Union[Variable, PiecewiseConstantSignal],
                     Tuple[float, float]]
    """List of all parameters with the upper and lower bounds"""

    path_constraints: casadi.Function
    """Function c(s, y, q, p) s.t. c >= 0 implies constraint is satisfied"""

    terminal_constraints: casadi.Function
    """Function C(1, y(1), q(1), p) such"""


def build_codesign_problem(problem: ConstrainedFunctional
                           ) -> CasadiCodesignProblemData:

    p = casadi.vertcat(*[
        casadi.MX.sym(str(param), *param.shape)
        for param in problem.parameters
    ])

    flattened_system = problem.system

    symbols = {
        s: casadi.MX.sym(f'{s.name}', len(s))
        for s in flattened_system.output_map.arguments[:-1]
    }

    p_arg, = problem.parameter_map.symbols()
    p_inner = flattened_system.output_map.arguments[-1]

    t_arg = flattened_system.output_map.arguments[0]
    # 0 < tau < 1 -> t = tau * T,
    #             -> df/dtau = df/dt * dt*dtau = T * df/dt
    tau = symbols[t_arg]
    t_final = substitute(problem.final_time, {p_arg: p})

    t = tau * t_final
    symbols[t_arg] = t

    symbols[p_inner] = substitute(problem.parameter_map.graph, {p_arg: p})
    dx = substitute(flattened_system.vector_field.graph, symbols)
    y = substitute(flattened_system.output_map.graph, symbols)
    try:
        x0 = substitute(flattened_system.initial_conditions.graph, symbols)
    except AttributeError:
        x0 = flattened_system.initial_conditions()

    _, x, z, u, _ = symbols.values()
    zu = casadi.vertcat(z, u)
    args = [tau, x, zu, p]

    f = casadi.Function('f', args, [t_final * dx])
    g = casadi.Function('g', args, [y])
    x0 = casadi.Function('x0', [p], [x0])

    if flattened_system.constraints:
        res = substitute(flattened_system.constraints.graph, symbols)
    else:
        res = casadi.MX()
    h = casadi.Function('h', args, [res])
    # build quadratures

    symbols = {
        s: casadi.MX.sym(f'{str(s)}', *s.shape)
        for s in problem.value.arguments
    }

    tau, y, q, p = list(symbols.values())
    symbols[problem.value.arguments[0]] *= t_final

    cost_impl = substitute(problem.value.graph, symbols)
    cost = casadi.Function('cost', [tau, y, q, p], [cost_impl])
    q_dot = casadi.Function(
        'q_dot', [tau, y, p],
        [t_final * substitute(problem.quadratures.graph, symbols)
         if problem.quadratures else casadi.MX()],
    )

    path_constraints = [
        substitute(c.graph, symbols) for c in problem.path_constraints
    ]
    c_t = casadi.Function(
        'c_t', [tau, y, q, p],
        [casadi.vertcat(*path_constraints)
         if path_constraints else casadi.MX()]
    )
    point_constraints = [
        substitute(c.graph, symbols) for c in problem.point_constraints
    ]
    terminal_constraint = casadi.Function(
        'c_T', [tau, y, q, p],
        [casadi.vertcat(*point_constraints)
         if point_constraints else casadi.MX()]
    )

    t_final_impl = casadi.Function('T', [p], [t_final])

    problem_data = CasadiCodesignProblemData(
        domain=problem.system.domain,
        vector_field=f,
        outputs=g,
        final_time=t_final_impl,
        algebraic_constraint=h,
        initial_conditions=x0,
        cost_function=cost,
        parameters=problem.parameters,
        quadrature=q_dot,
        path_constraints=c_t,
        terminal_constraints=terminal_constraint,
    )

    return problem_data


def evaluate_problem(problem_data: CasadiCodesignProblemData,
                     options: CasadiSolverOptions, p):

    x0 = problem_data.initial_conditions(p)
    dim_x = problem_data.domain.states

    dim_z = problem_data.domain.constraints + problem_data.domain.inputs
    t = casadi.MX.sym('t')
    x = casadi.MX.sym('x', dim_x)
    t_final = problem_data.final_time(p)
    z = casadi.MX.sym('z', dim_z)
    f_impl = casadi.vertcat(
        casadi.MX.ones(1, 1),
        problem_data.vector_field(t, x, z, p)
    )
    dae_spec = {
        'x': casadi.vertcat(t, x),
        'ode': f_impl,
    }
    solver_args = dict(x0=casadi.vertcat(0, x0))
    if dim_z > 0:
        residue = problem_data.algebraic_constraint(0, x0, z, p)
        objective = casadi.Function('z0', [z], [residue])
        z0 = casadi.rootfinder('z0', 'newton', objective)([0] * dim_z)
        h_impl = problem_data.algebraic_constraint(t, x, z, p)
        dae_spec.update({
            'z': z,
            'alg': h_impl,
        })
        solver_args['z0'] = z0

    y = problem_data.outputs(t, x, z, p)
    q_dot = problem_data.quadrature(t, y, p)

    if q_dot.shape[0] > 0:
        dae_spec['quad']: q_dot

    dae_options = {
        'grid': np.linspace(0, 1, options.grid_size + 1),
        'output_t0': True
    }
    solver = casadi.integrator('dae', 'idas', dae_spec, dae_options)

    tx = casadi.MX.sym('X', 1 + dim_x, options.grid_size + 1)
    t, x = tx[0, :]*t_final, tx[1:, :]
    z = casadi.MX.sym('Z', dim_z, options.grid_size + 1)
    q = casadi.MX.sym('Q', q_dot.shape[0], options.grid_size + 1)
    p_matrix = casadi.repmat(p, 1, options.grid_size + 1)
    g_out = problem_data.outputs.map(options.grid_size + 1)
    g_constraint = problem_data.path_constraints.map(options.grid_size + 1)

    y = g_out(t, x, z, p_matrix)
    c_t = g_constraint(t, y, q, p_matrix)

    c_point = problem_data.terminal_constraints(t[-1], y[:, -1], q[:, -1], p)

    cost = problem_data.cost_function(y[-1], y[:, -1], q[:, -1], p)
    soln_to_cost = casadi.Function(
        'cost', [tx, z, q], [cost], ['xf', 'zf', 'qf'], ['cost']
    )
    soln_to_path = casadi.Function(
        'path', [tx, z, q],
        [t, y, q, c_t, c_point],
        ['xf', 'zf', 'qf'],
        ['t', 'y', 'q', 'c_t', 'c_T']
    )

    return solver, solver_args, soln_to_cost, soln_to_path


def transcribe_problem(problem_data: CasadiCodesignProblemData,
                       options: CasadiSolverOptions, p_guess):

    equality_constraints = []   # all constraints == 0
    inequality_constraints = [] # all constraints >= 0

    times, colloc_coeff, diff_coeff, quad_coeff = get_collocation_matrices(
        options.polynomial_degree
    )

    param_factory = ParameterFactory(problem_data.parameters)

    q = 0  # quadrature variables
    s = 0  # 'progress' along path between 0 and 1
    p = param_factory(0)

    x0 = problem_data.initial_conditions(p)

    state_factory = StateFactory(problem_data, options, p_guess)

    x, z = state_factory.new_terminal(0)
    equality_constraints.append(x - x0)
    y = problem_data.outputs(s, x, z, p)
    ds = 1 / options.grid_size
    s_out = [0]
    y_out = [y]
    q_out = [q]
    c_t_out = []
    equality_constraints.append(problem_data.algebraic_constraint(s, x, z, p))
    inequality_constraints.append(problem_data.path_constraints(s, y, q, p))

    for k in range(options.grid_size):
        x_jk, z_jk = state_factory.new_collocation_points(
            k, options.polynomial_degree
        )

        x_next = diff_coeff[0] * x
        for j in range(1, options.polynomial_degree + 1):
            # Todo: Check if this indexing is right as C[:, 0] is never used
            dx = colloc_coeff[0, j] * x
            dx += sum(
                c_ij * x_ij
                for c_ij, x_ij in zip(colloc_coeff[1:, j], x_jk)
            )
            s_j = s + times[j - 1] * ds
            args = [s_j, x_jk[j - 1], z_jk[j - 1], p]
            f_inter = problem_data.vector_field(*args)
            res_inter = problem_data.algebraic_constraint(*args)
            equality_constraints.append(res_inter)
            y_j = problem_data.outputs(*args)
            equality_constraints.append(ds * f_inter - dx)

            q_dot = problem_data.quadrature(s_j, y_j, p)
            q += quad_coeff[j] * q_dot * ds
            x_next = x_next + diff_coeff[j] * x_jk[j - 1]

        s += ds

        x, z = state_factory.new_terminal(k + 1)

        p = param_factory(k)
        equality_constraints.append(x - x_next)
        equality_constraints.append(
            problem_data.algebraic_constraint(s, x, z, p)
        )
        y = problem_data.outputs(s, x, z, p)

        c_j = problem_data.path_constraints(s, y, q, p)
        c_t_out.append(c_j)
        inequality_constraints.append(c_j)

        s_out.append(s)
        y_out.append(y)
        q_out.append(q)

    cost = problem_data.cost_function(s, y, q, p)
    c_final = problem_data.terminal_constraints(s, y, q, p)
    inequality_constraints.append(c_final)

    x_array, x_min, x_max, x_initial = state_factory.finalise()
    p_array, p_min, p_max, p_initial = param_factory.finalise()
    cost += param_factory.regularisation_cost()
    nlp_vars = casadi.vertcat(p_array, x_array)
    nlp_min = casadi.vertcat(p_min, x_min)
    nlp_max = casadi.vertcat(p_max, x_max)
    nlp_init = casadi.vertcat(p_initial, x_initial)

    eq = casadi.vertcat(*equality_constraints)
    ineq = casadi.vertcat(*inequality_constraints)
    c = casadi.vertcat(eq, ineq)
    c_min = np.zeros(c.shape, dtype=float)
    if ineq.shape != (0, 0):
        c_max = np.concatenate([np.zeros(eq.shape),
                                np.inf * np.ones(ineq.shape)])
    else:
        c_max = np.zeros(c.shape)

    nlp_spec = {
        'f': cost,
        'x': nlp_vars,
        'g': c
    }

    nlp_args = {
        'x0': nlp_init,
        'lbx': nlp_min,
        'ubx': nlp_max,
        'lbg': c_min,
        'ubg': c_max,
        'lam_x0': np.zeros(nlp_init.shape),
        'lam_g0': np.zeros(c_max.shape)
    }

    solver = casadi.nlpsol(
        'problem', options.solver, nlp_spec,
        {options.solver: options.solver_options}
    )

    sol_to_min_and_argmin = casadi.Function(
        'argmim',
        [nlp_vars],
        param_factory.output_list()
    )

    s_out = casadi.horzcat(*s_out) * problem_data.final_time(p)
    y_out = casadi.horzcat(*y_out)
    q_out = casadi.horzcat(*q_out)

    sol_to_path = casadi.Function(
        'trajectory',
        [nlp_vars],
        [s_out, y_out, q_out, casadi.horzcat(*c_t_out), c_final]
    )

    return solver, nlp_args, sol_to_min_and_argmin, sol_to_path


def solve(problem: CasadiCodesignProblemData,
          initial_values,
          options: Optional[CasadiSolverOptions] = None) -> CodesignSolution:
    """Minimise the constrained function to sovle the codesign problem"""
    # set cost - problem.cost
    #

    opts = options or CasadiSolverOptions()
    solver, solver_args, prob, path = transcribe_problem(
        problem, opts, initial_values
    )

    result = solver(**solver_args)
    value = result['f'].full()
    argmin_vec = prob(result['x'])
    if len(problem.parameters) == 1:
        argmin_vec = [argmin_vec]
    elif len(problem.parameters) == 0:
        argmin_vec = []

    argmin = {
        p: argmin.full() for p, argmin in zip(problem.parameters, argmin_vec)
    }

    t, y, q, c_t, c_final = [a.full() for a in path(result['x'])]

    return CodesignSolution(cost=value,
                            argmin=argmin,
                            time=t,
                            outputs=y,
                            quadratures=q,
                            path_constraints=c_t,
                            point_constraints=c_final)


@backend.implements(ConstrainedFunctional)
class CodesignSolver:
    """Solver for the fixed-time codesign problem"""
    def __init__(self, problem):
        self.data = build_codesign_problem(problem)

    def __call__(self, *args, options: Optional[CasadiSolverOptions]=None):
        """Evaluates the constrained functional with the given parameters.

        Args: list of values for decision variables."""
        opts = options or CasadiSolverOptions()
        solver, solver_args, cost_fn, path = evaluate_problem(
            self.data,
            opts,
            args)

        # set cost = |param - args|^2
        # solve codesign problem
        # evaluate cost function
        # return result
        soln = solver(**solver_args)
        x, z, q = (soln[key] for key in ('xf', 'zf', 'qf'))
        cost = cost_fn(x, z, q)
        t, y, q, c_t, c_final = [a.full() for a in path(x, z, q)]
        return CodesignSolution(
            cost=cost.full(),
            argmin=args,
            time=t,
            outputs=y,
            quadratures=q,
            path_constraints=c_t,
            point_constraints=c_final
        )

    def minimise(self,
                 initial_values,
                 options: CasadiSolverOptions) -> CodesignSolution:
        """Minimise the constrained function to sovle the codesign problem"""

        return solve(self.data, initial_values, options)

    def solve_feasibility(self,
                          guess,
                          options: Optional[CasadiSolverOptions] = None):
        opts = options or CasadiSolverOptions()
        problem = build_feasibility_problem(
            self.data,  guess, opts
        )
        soln = solve(problem, [0] * len(problem.parameters), opts)
        return soln


def build_feasibility_problem(
            problem: CasadiCodesignProblemData,
            guess,
            options: CasadiSolverOptions):
    # The feasibility problem involves adding some slack variables
    # to the constraints, setting these variables to be in (-eps, infty)
    # and then minimising the sum of the slack variables.
    # This means that the cost is linear, and the constraint set is much
    # looser than the initial problem
    # If a feasible solution exists, the cost will be zero.

    parameters = {}
    p_guess = []
    p_initial = []
    p_ctrl = []
    for i, (param, value) in enumerate(problem.parameters.items()):
        if isinstance(param, PiecewiseConstantSignal):
            parameters[param] = value
            u = casadi.MX.sym(param.name)
            p_ctrl.append(u)
            p_guess.append(u)
            p_initial.append(guess[i])
        else:
            p_guess.append(casadi.MX(guess[i]))

    n_path, _ = problem.path_constraints.size_out(0)
    n_point, _ = problem.terminal_constraints.size_out(0)

    for i in range(n_path):
        mu_i = Variable(f'c_{i}')
        parameters[mu_i] = (-options.constraint_tolerance, np.inf)
        p_initial.append(0)

    for i in range(n_point):
        nu_i = Variable(f'C_{i}')
        parameters[nu_i] = (-options.constraint_tolerance, np.inf)
        p_initial.append(0)

    tau = casadi.MX.sym('tau')
    x = casadi.MX.sym('x',  problem.domain.states)
    zu = casadi.MX.sym('zu', problem.domain.constraints + problem.domain.inputs)
    p_guess = casadi.vertcat(*p_guess)

    mu_sym = casadi.MX.sym('mu', n_path)
    nu_sym = casadi.MX.sym('nu', n_point)
    p = casadi.vertcat(*p_ctrl, mu_sym, nu_sym)

    args = [tau, x, zu, p]
    args_inner = [tau, x, zu, p_guess]
    f = casadi.Function(
        'f', args, [problem.vector_field(*args_inner)]
    )
    g = casadi.Function(
        'g', args, [problem.outputs(*args_inner)]
    )

    x0 = casadi.Function(
        'x0', [p], [problem.initial_conditions(p_guess)]
    )
    h = casadi.Function(
        'h', args, [problem.algebraic_constraint(*args_inner)]
    )

    q = casadi.MX.sym('q', *problem.quadrature.size_out(0))
    y = casadi.MX.sym('y', *problem.outputs.size_out(0))

    q_dot = casadi.Function(
        'q_dot', [tau, y, p], [problem.quadrature(tau, y, p_guess)]
    )
    ones_mu = casadi.MX.ones(*mu_sym.shape)
    ones_nu = casadi.MX.ones(*nu_sym.shape)
    cost = casadi.Function(
        'cost', [tau, y, q, p], [ones_mu.T @ mu_sym + ones_nu.T @ nu_sym]
    )
    path_constraint = casadi.Function(
        'c_t',
        [tau, y, q, p],
        [mu_sym if n_path == 0
         else mu_sym + problem.path_constraints(tau, y, q, p_guess)]
    )
    termina_constraint = casadi.Function(
        'c_T',
        [tau, y, q, p],
        [nu_sym if n_point == 0
         else nu_sym + problem.terminal_constraints(tau, y, q, p_guess)
         ]
    )
    t_final = casadi.Function(
        't_f',
        [p],
        [problem.final_time(p_guess)]
    )

    feasability_problem = CasadiCodesignProblemData(
        domain=problem.domain,
        vector_field=f,
        outputs=g,
        final_time=t_final,
        algebraic_constraint=h,
        initial_conditions=x0,
        quadrature=q_dot,
        cost_function=cost,
        parameters=parameters,
        path_constraints=path_constraint,
        terminal_constraints=termina_constraint
    )
    return feasability_problem


def is_feasible(data: CasadiCodesignProblemData,
                parameters,
                options: Optional[CasadiSolverOptions] = None):
    assert len(parameters) == len(data.parameters)
    opts = options or CasadiSolverOptions()
    problem = build_feasibility_problem(
        data,
        parameters,
        opts
    )
    soln = solve(problem,
                 [0] * len(problem.parameters),
                 options)
    return soln.cost < opts.constraint_tolerance

