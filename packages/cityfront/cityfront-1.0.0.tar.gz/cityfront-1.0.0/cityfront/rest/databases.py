"""DO NOT EDIT THIS FILE!

This file is auto generated by github rest api discription.
See https://github.com/github/rest-api-description for more information.
"""


from typing import Literal
from typing import Union
from .models import DatabaseList
from cityfront.utils import UNSET, Unset
from .models import Database
from typing import Union
from .models import Payload16
from cityfront.utils import UNSET, Unset
from .types import Payload16Type
from typing import Literal
from typing import Union
from cityfront.utils import UNSET, Unset
from .models import UsageDatabases
from .models import Database
from typing import Literal
from .models import Database
from .models import Payload17
from typing import Union
from .types import Payload17Type
from cityfront.utils import UNSET, Unset
from typing import Literal
from typing import Literal
from typing import Union
from .models import CollectionList
from cityfront.utils import UNSET, Unset
from .types import Payload18Type
from .models import Payload18
from typing import Union
from typing import List
from .models import Collection
from cityfront.utils import UNSET, Unset
from .models import Collection
from typing import Literal
from typing import Union
from .models import Payload19
from .types import Payload19Type
from typing import List
from .models import Collection
from cityfront.utils import UNSET, Unset
from typing import Literal
from typing import Literal
from .models import AttributeList
from typing import Union
from .types import Payload20Type
from cityfront.utils import UNSET, Unset
from .models import AttributeBoolean
from .models import Payload20
from typing import Union
from .models import Payload21
from cityfront.utils import UNSET, Unset
from .models import AttributeEmail
from .types import Payload21Type
from typing import Union
from .types import Payload22Type
from .models import AttributeEnum
from typing import List
from .models import Payload22
from cityfront.utils import UNSET, Unset
from typing import Union
from .types import Payload23Type
from .models import Payload23
from .models import AttributeFloat
from cityfront.utils import UNSET, Unset
from typing import Union
from .models import AttributeInteger
from .models import Payload24
from .types import Payload24Type
from cityfront.utils import UNSET, Unset
from .models import AttributeIp
from typing import Union
from .models import Payload21
from cityfront.utils import UNSET, Unset
from .types import Payload21Type
from .models import Payload26
from typing import Union
from .models import AttributeString
from .types import Payload26Type
from cityfront.utils import UNSET, Unset
from typing import Union
from .models import Payload21
from .models import AttributeUrl
from cityfront.utils import UNSET, Unset
from .types import Payload21Type
from typing import Any
from typing import Literal
from typing import Literal
from typing import Literal
from typing import Union
from typing import List
from cityfront.utils import UNSET, Unset
from .models import DocumentList
from .types import Payload28PropDataType
from .types import Payload28Type
from typing import Union
from .models import Document
from typing import List
from .models import Payload28
from cityfront.utils import UNSET, Unset
from typing import Literal
from .models import Document
from typing import Literal
from typing import Union
from .models import Payload29
from .types import Payload29Type
from .models import Document
from typing import List
from cityfront.utils import UNSET, Unset
from .types import Payload29PropDataType
from typing import Literal
from typing import Union
from .models import LogList
from cityfront.utils import UNSET, Unset
from typing import Literal
from .models import IndexList
from typing import Union
from .models import Index
from typing import List
from .models import Payload30
from cityfront.utils import UNSET, Unset
from .types import Payload30Type
from .models import Index
from typing import Literal
from typing import Literal
from typing import Literal
from typing import Union
from .models import LogList
from cityfront.utils import UNSET, Unset
from typing import Literal
from typing import Union
from cityfront.utils import UNSET, Unset
from .models import UsageCollection
from typing import Literal
from typing import Union
from .models import LogList
from cityfront.utils import UNSET, Unset
from .models import UsageDatabase
from typing import Literal
from typing import Union
from cityfront.utils import UNSET, Unset

from typing import TYPE_CHECKING, overload

from pydantic import BaseModel, parse_obj_as

from cityfront.utils import exclude_unset

if TYPE_CHECKING:
    from cityfront import AppWrite
    from cityfront.response import Response


class DatabasesClient:
    def __init__(self, appwrite: 'AppWrite'):
        self._appwrite = appwrite

    def databases_list(
        self,
        search: Union[Unset, str] = UNSET,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
        cursor: Union[Unset, str] = UNSET,
        cursor_direction: Union[Unset, str] = 'after',
        order_type: Union[Unset, str] = 'ASC',
    ) -> 'Response[DatabaseList]':
        headers = {}
        url = '/databases'

        params = {
            'search': search,
            'limit': limit,
            'offset': offset,
            'cursor': cursor,
            'cursorDirection': cursor_direction,
            'orderType': order_type,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=DatabaseList,
        )

    async def async_databases_list(
        self,
        search: Union[Unset, str] = UNSET,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
        cursor: Union[Unset, str] = UNSET,
        cursor_direction: Union[Unset, str] = 'after',
        order_type: Union[Unset, str] = 'ASC',
    ) -> 'Response[DatabaseList]':
        url = '/databases'

        params = {
            'search': search,
            'limit': limit,
            'offset': offset,
            'cursor': cursor,
            'cursorDirection': cursor_direction,
            'orderType': order_type,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=DatabaseList,
        )

    @overload
    def databases_create(
        self, *, data: Union[Unset, Payload16Type] = UNSET
    ) -> 'Response[Database]':
        ...

    @overload
    def databases_create(
        self,
        *,
        data: Unset = UNSET,
        database_id: str,
        name: str,
    ) -> 'Response[Database]':
        ...

    def databases_create(
        self, *, data: Union[Unset, Payload16Type] = UNSET, **kwargs
    ) -> 'Response[Database]':
        headers = {}
        url = '/databases'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload16, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Database,
        )

    @overload
    async def async_databases_create(
        self, *, data: Union[Unset, Payload16Type] = UNSET
    ) -> 'Response[Database]':
        ...

    @overload
    async def async_databases_create(
        self,
        *,
        data: Unset = UNSET,
        database_id: str,
        name: str,
    ) -> 'Response[Database]':
        ...

    async def async_databases_create(
        self, *, data: Union[Unset, Payload16Type] = UNSET, **kwargs
    ) -> 'Response[Database]':
        url = '/databases'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload16, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Database,
        )

    def databases_get_usage(
        self,
        range_: Union[Unset, str] = '30d',
    ) -> 'Response[UsageDatabases]':
        headers = {}
        url = '/databases/usage'

        params = {
            'range': range_,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=UsageDatabases,
        )

    async def async_databases_get_usage(
        self,
        range_: Union[Unset, str] = '30d',
    ) -> 'Response[UsageDatabases]':
        url = '/databases/usage'

        params = {
            'range': range_,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=UsageDatabases,
        )

    def databases_get(
        self,
        database_id: str,
    ) -> 'Response[Database]':
        headers = {}
        url = f'/databases/{database_id}'

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Database,
        )

    async def async_databases_get(
        self,
        database_id: str,
    ) -> 'Response[Database]':
        url = f'/databases/{database_id}'

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Database,
        )

    @overload
    def databases_update(
        self, database_id: str, *, data: Union[Unset, Payload17Type] = UNSET
    ) -> 'Response[Database]':
        ...

    @overload
    def databases_update(
        self,
        database_id: str,
        *,
        data: Unset = UNSET,
        name: str,
    ) -> 'Response[Database]':
        ...

    def databases_update(
        self,
        database_id: str,
        *,
        data: Union[Unset, Payload17Type] = UNSET,
        **kwargs,
    ) -> 'Response[Database]':
        headers = {}
        url = f'/databases/{database_id}'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload17, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'PUT',
            url,
            json=exclude_unset(json),
            response_model=Database,
        )

    @overload
    async def async_databases_update(
        self, database_id: str, *, data: Union[Unset, Payload17Type] = UNSET
    ) -> 'Response[Database]':
        ...

    @overload
    async def async_databases_update(
        self,
        database_id: str,
        *,
        data: Unset = UNSET,
        name: str,
    ) -> 'Response[Database]':
        ...

    async def async_databases_update(
        self,
        database_id: str,
        *,
        data: Union[Unset, Payload17Type] = UNSET,
        **kwargs,
    ) -> 'Response[Database]':
        url = f'/databases/{database_id}'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload17, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'PUT',
            url,
            json=exclude_unset(json),
            response_model=Database,
        )

    def databases_delete(
        self,
        database_id: str,
    ) -> 'Response':
        headers = {}
        url = f'/databases/{database_id}'

        return self._appwrite.request(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    async def async_databases_delete(
        self,
        database_id: str,
    ) -> 'Response':
        url = f'/databases/{database_id}'

        headers = {}
        return await self._appwrite.arequest(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    def databases_list_collections(
        self,
        database_id: str,
        search: Union[Unset, str] = UNSET,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
        cursor: Union[Unset, str] = UNSET,
        cursor_direction: Union[Unset, str] = 'after',
        order_type: Union[Unset, str] = 'ASC',
    ) -> 'Response[CollectionList]':
        headers = {}
        url = f'/databases/{database_id}/collections'

        params = {
            'search': search,
            'limit': limit,
            'offset': offset,
            'cursor': cursor,
            'cursorDirection': cursor_direction,
            'orderType': order_type,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=CollectionList,
        )

    async def async_databases_list_collections(
        self,
        database_id: str,
        search: Union[Unset, str] = UNSET,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
        cursor: Union[Unset, str] = UNSET,
        cursor_direction: Union[Unset, str] = 'after',
        order_type: Union[Unset, str] = 'ASC',
    ) -> 'Response[CollectionList]':
        url = f'/databases/{database_id}/collections'

        params = {
            'search': search,
            'limit': limit,
            'offset': offset,
            'cursor': cursor,
            'cursorDirection': cursor_direction,
            'orderType': order_type,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=CollectionList,
        )

    @overload
    def databases_create_collection(
        self, database_id: str, *, data: Union[Unset, Payload18Type] = UNSET
    ) -> 'Response[Collection]':
        ...

    @overload
    def databases_create_collection(
        self,
        database_id: str,
        *,
        data: Unset = UNSET,
        collection_id: str,
        name: str,
        permission: str,
        read: List[str],
        write: List[str],
    ) -> 'Response[Collection]':
        ...

    def databases_create_collection(
        self,
        database_id: str,
        *,
        data: Union[Unset, Payload18Type] = UNSET,
        **kwargs,
    ) -> 'Response[Collection]':
        headers = {}
        url = f'/databases/{database_id}/collections'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload18, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Collection,
        )

    @overload
    async def async_databases_create_collection(
        self, database_id: str, *, data: Union[Unset, Payload18Type] = UNSET
    ) -> 'Response[Collection]':
        ...

    @overload
    async def async_databases_create_collection(
        self,
        database_id: str,
        *,
        data: Unset = UNSET,
        collection_id: str,
        name: str,
        permission: str,
        read: List[str],
        write: List[str],
    ) -> 'Response[Collection]':
        ...

    async def async_databases_create_collection(
        self,
        database_id: str,
        *,
        data: Union[Unset, Payload18Type] = UNSET,
        **kwargs,
    ) -> 'Response[Collection]':
        url = f'/databases/{database_id}/collections'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload18, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Collection,
        )

    def databases_get_collection(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response[Collection]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}'

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Collection,
        )

    async def async_databases_get_collection(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response[Collection]':
        url = f'/databases/{database_id}/collections/{collection_id}'

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Collection,
        )

    @overload
    def databases_update_collection(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload19Type] = UNSET,
    ) -> 'Response[Collection]':
        ...

    @overload
    def databases_update_collection(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        name: str,
        permission: str,
        read: Union[Unset, List[str]] = UNSET,
        write: Union[Unset, List[str]] = UNSET,
        enabled: Union[Unset, bool] = True,
    ) -> 'Response[Collection]':
        ...

    def databases_update_collection(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload19Type] = UNSET,
        **kwargs,
    ) -> 'Response[Collection]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload19, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'PUT',
            url,
            json=exclude_unset(json),
            response_model=Collection,
        )

    @overload
    async def async_databases_update_collection(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload19Type] = UNSET,
    ) -> 'Response[Collection]':
        ...

    @overload
    async def async_databases_update_collection(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        name: str,
        permission: str,
        read: Union[Unset, List[str]] = UNSET,
        write: Union[Unset, List[str]] = UNSET,
        enabled: Union[Unset, bool] = True,
    ) -> 'Response[Collection]':
        ...

    async def async_databases_update_collection(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload19Type] = UNSET,
        **kwargs,
    ) -> 'Response[Collection]':
        url = f'/databases/{database_id}/collections/{collection_id}'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload19, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'PUT',
            url,
            json=exclude_unset(json),
            response_model=Collection,
        )

    def databases_delete_collection(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}'

        return self._appwrite.request(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    async def async_databases_delete_collection(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response':
        url = f'/databases/{database_id}/collections/{collection_id}'

        headers = {}
        return await self._appwrite.arequest(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    def databases_list_attributes(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response[AttributeList]':
        headers = {}
        url = (
            f'/databases/{database_id}/collections/{collection_id}/attributes'
        )

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=AttributeList,
        )

    async def async_databases_list_attributes(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response[AttributeList]':
        url = (
            f'/databases/{database_id}/collections/{collection_id}/attributes'
        )

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=AttributeList,
        )

    @overload
    def databases_create_boolean_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload20Type] = UNSET,
    ) -> 'Response[AttributeBoolean]':
        ...

    @overload
    def databases_create_boolean_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, bool] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeBoolean]':
        ...

    def databases_create_boolean_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload20Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeBoolean]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/boolean'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload20, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeBoolean,
        )

    @overload
    async def async_databases_create_boolean_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload20Type] = UNSET,
    ) -> 'Response[AttributeBoolean]':
        ...

    @overload
    async def async_databases_create_boolean_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, bool] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeBoolean]':
        ...

    async def async_databases_create_boolean_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload20Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeBoolean]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/boolean'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload20, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeBoolean,
        )

    @overload
    def databases_create_email_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
    ) -> 'Response[AttributeEmail]':
        ...

    @overload
    def databases_create_email_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeEmail]':
        ...

    def databases_create_email_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeEmail]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/email'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload21, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeEmail,
        )

    @overload
    async def async_databases_create_email_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
    ) -> 'Response[AttributeEmail]':
        ...

    @overload
    async def async_databases_create_email_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeEmail]':
        ...

    async def async_databases_create_email_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeEmail]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/email'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload21, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeEmail,
        )

    @overload
    def databases_create_enum_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload22Type] = UNSET,
    ) -> 'Response[AttributeEnum]':
        ...

    @overload
    def databases_create_enum_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        elements: List[str],
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeEnum]':
        ...

    def databases_create_enum_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload22Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeEnum]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/enum'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload22, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeEnum,
        )

    @overload
    async def async_databases_create_enum_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload22Type] = UNSET,
    ) -> 'Response[AttributeEnum]':
        ...

    @overload
    async def async_databases_create_enum_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        elements: List[str],
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeEnum]':
        ...

    async def async_databases_create_enum_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload22Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeEnum]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/enum'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload22, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeEnum,
        )

    @overload
    def databases_create_float_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload23Type] = UNSET,
    ) -> 'Response[AttributeFloat]':
        ...

    @overload
    def databases_create_float_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        min_: Union[Unset, float] = UNSET,
        max_: Union[Unset, float] = UNSET,
        default: Union[Unset, float] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeFloat]':
        ...

    def databases_create_float_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload23Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeFloat]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/float'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload23, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeFloat,
        )

    @overload
    async def async_databases_create_float_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload23Type] = UNSET,
    ) -> 'Response[AttributeFloat]':
        ...

    @overload
    async def async_databases_create_float_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        min_: Union[Unset, float] = UNSET,
        max_: Union[Unset, float] = UNSET,
        default: Union[Unset, float] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeFloat]':
        ...

    async def async_databases_create_float_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload23Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeFloat]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/float'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload23, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeFloat,
        )

    @overload
    def databases_create_integer_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload24Type] = UNSET,
    ) -> 'Response[AttributeInteger]':
        ...

    @overload
    def databases_create_integer_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        min_: Union[Unset, int] = UNSET,
        max_: Union[Unset, int] = UNSET,
        default: Union[Unset, int] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeInteger]':
        ...

    def databases_create_integer_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload24Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeInteger]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/integer'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload24, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeInteger,
        )

    @overload
    async def async_databases_create_integer_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload24Type] = UNSET,
    ) -> 'Response[AttributeInteger]':
        ...

    @overload
    async def async_databases_create_integer_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        min_: Union[Unset, int] = UNSET,
        max_: Union[Unset, int] = UNSET,
        default: Union[Unset, int] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeInteger]':
        ...

    async def async_databases_create_integer_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload24Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeInteger]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/integer'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload24, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeInteger,
        )

    @overload
    def databases_create_ip_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
    ) -> 'Response[AttributeIp]':
        ...

    @overload
    def databases_create_ip_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeIp]':
        ...

    def databases_create_ip_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeIp]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/ip'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload21, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeIp,
        )

    @overload
    async def async_databases_create_ip_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
    ) -> 'Response[AttributeIp]':
        ...

    @overload
    async def async_databases_create_ip_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeIp]':
        ...

    async def async_databases_create_ip_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeIp]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/ip'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload21, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeIp,
        )

    @overload
    def databases_create_string_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload26Type] = UNSET,
    ) -> 'Response[AttributeString]':
        ...

    @overload
    def databases_create_string_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        size: int,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeString]':
        ...

    def databases_create_string_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload26Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeString]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/string'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload26, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeString,
        )

    @overload
    async def async_databases_create_string_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload26Type] = UNSET,
    ) -> 'Response[AttributeString]':
        ...

    @overload
    async def async_databases_create_string_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        size: int,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeString]':
        ...

    async def async_databases_create_string_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload26Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeString]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/string'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload26, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeString,
        )

    @overload
    def databases_create_url_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
    ) -> 'Response[AttributeUrl]':
        ...

    @overload
    def databases_create_url_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeUrl]':
        ...

    def databases_create_url_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeUrl]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/url'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload21, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeUrl,
        )

    @overload
    async def async_databases_create_url_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
    ) -> 'Response[AttributeUrl]':
        ...

    @overload
    async def async_databases_create_url_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        required: bool,
        default: Union[Unset, str] = UNSET,
        array: Union[Unset, bool] = False,
    ) -> 'Response[AttributeUrl]':
        ...

    async def async_databases_create_url_attribute(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload21Type] = UNSET,
        **kwargs,
    ) -> 'Response[AttributeUrl]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/url'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload21, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=AttributeUrl,
        )

    def databases_get_attribute(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response[Any]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/{key}'

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Any,
        )

    async def async_databases_get_attribute(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response[Any]':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/{key}'

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Any,
        )

    def databases_delete_attribute(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/{key}'

        return self._appwrite.request(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    async def async_databases_delete_attribute(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response':
        url = f'/databases/{database_id}/collections/{collection_id}/attributes/{key}'

        headers = {}
        return await self._appwrite.arequest(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    def databases_list_documents(
        self,
        database_id: str,
        collection_id: str,
        queries: Union[Unset, List[str]] = UNSET,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
        cursor: Union[Unset, str] = UNSET,
        cursor_direction: Union[Unset, str] = 'after',
        order_attributes: Union[Unset, List[str]] = UNSET,
        order_types: Union[Unset, List[str]] = UNSET,
    ) -> 'Response[DocumentList]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/documents'

        params = {
            'queries': queries,
            'limit': limit,
            'offset': offset,
            'cursor': cursor,
            'cursorDirection': cursor_direction,
            'orderAttributes': order_attributes,
            'orderTypes': order_types,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=DocumentList,
        )

    async def async_databases_list_documents(
        self,
        database_id: str,
        collection_id: str,
        queries: Union[Unset, List[str]] = UNSET,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
        cursor: Union[Unset, str] = UNSET,
        cursor_direction: Union[Unset, str] = 'after',
        order_attributes: Union[Unset, List[str]] = UNSET,
        order_types: Union[Unset, List[str]] = UNSET,
    ) -> 'Response[DocumentList]':
        url = f'/databases/{database_id}/collections/{collection_id}/documents'

        params = {
            'queries': queries,
            'limit': limit,
            'offset': offset,
            'cursor': cursor,
            'cursorDirection': cursor_direction,
            'orderAttributes': order_attributes,
            'orderTypes': order_types,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=DocumentList,
        )

    @overload
    def databases_create_document(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload28Type] = UNSET,
    ) -> 'Response[Document]':
        ...

    @overload
    def databases_create_document(
        self,
        database_id: str,
        collection_id: str,
        *,
        document_id: str,
        data: Union[Unset, Payload28PropDataType],
        read: Union[Unset, List[str]] = UNSET,
        write: Union[Unset, List[str]] = UNSET,
    ) -> 'Response[Document]':
        ...

    def databases_create_document(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload28Type] = UNSET,
        **kwargs,
    ) -> 'Response[Document]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/documents'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload28, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Document,
        )

    @overload
    async def async_databases_create_document(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload28Type] = UNSET,
    ) -> 'Response[Document]':
        ...

    @overload
    async def async_databases_create_document(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload28PropDataType],
        document_id: str,
        read: Union[Unset, List[str]] = UNSET,
        write: Union[Unset, List[str]] = UNSET,
    ) -> 'Response[Document]':
        ...

    async def async_databases_create_document(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload28Type] = UNSET,
        **kwargs,
    ) -> 'Response[Document]':
        url = f'/databases/{database_id}/collections/{collection_id}/documents'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload28, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Document,
        )

    def databases_get_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
    ) -> 'Response[Document]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}'

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Document,
        )

    async def async_databases_get_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
    ) -> 'Response[Document]':
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}'

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Document,
        )

    def databases_delete_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
    ) -> 'Response':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}'

        return self._appwrite.request(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    async def async_databases_delete_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
    ) -> 'Response':
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}'

        headers = {}
        return await self._appwrite.arequest(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    @overload
    def databases_update_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        *,
        data: Union[Unset, Payload29Type] = UNSET,
    ) -> 'Response[Document]':
        ...

    @overload
    def databases_update_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        *,
        data: Union[Unset, Payload28PropDataType],
        read: Union[Unset, List[str]] = UNSET,
        write: Union[Unset, List[str]] = UNSET,
    ) -> 'Response[Document]':
        ...

    def databases_update_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        *,
        data: Union[Unset, Payload29Type] = UNSET,
        **kwargs,
    ) -> 'Response[Document]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload29, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'PATCH',
            url,
            json=exclude_unset(json),
            response_model=Document,
        )

    @overload
    async def async_databases_update_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        *,
        data: Union[Unset, Payload29Type] = UNSET,
    ) -> 'Response[Document]':
        ...

    @overload
    async def async_databases_update_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        *,
        data: Union[Unset, Payload29PropDataType] = UNSET,
        read: Union[Unset, List[str]] = UNSET,
        write: Union[Unset, List[str]] = UNSET,
    ) -> 'Response[Document]':
        ...

    async def async_databases_update_document(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        *,
        data: Union[Unset, Payload29Type] = UNSET,
        **kwargs,
    ) -> 'Response[Document]':
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload29, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'PATCH',
            url,
            json=exclude_unset(json),
            response_model=Document,
        )

    def databases_list_document_logs(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
    ) -> 'Response[LogList]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}/logs'

        params = {
            'limit': limit,
            'offset': offset,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=LogList,
        )

    async def async_databases_list_document_logs(
        self,
        database_id: str,
        collection_id: str,
        document_id: str,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
    ) -> 'Response[LogList]':
        url = f'/databases/{database_id}/collections/{collection_id}/documents/{document_id}/logs'

        params = {
            'limit': limit,
            'offset': offset,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=LogList,
        )

    def databases_list_indexes(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response[IndexList]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/indexes'

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=IndexList,
        )

    async def async_databases_list_indexes(
        self,
        database_id: str,
        collection_id: str,
    ) -> 'Response[IndexList]':
        url = f'/databases/{database_id}/collections/{collection_id}/indexes'

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=IndexList,
        )

    @overload
    def databases_create_index(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload30Type] = UNSET,
    ) -> 'Response[Index]':
        ...

    @overload
    def databases_create_index(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        type: str,
        attributes: List[str],
        orders: Union[Unset, List[str]] = [],
    ) -> 'Response[Index]':
        ...

    def databases_create_index(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload30Type] = UNSET,
        **kwargs,
    ) -> 'Response[Index]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/indexes'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload30, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        return self._appwrite.request(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Index,
        )

    @overload
    async def async_databases_create_index(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload30Type] = UNSET,
    ) -> 'Response[Index]':
        ...

    @overload
    async def async_databases_create_index(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Unset = UNSET,
        key: str,
        type: str,
        attributes: List[str],
        orders: Union[Unset, List[str]] = [],
    ) -> 'Response[Index]':
        ...

    async def async_databases_create_index(
        self,
        database_id: str,
        collection_id: str,
        *,
        data: Union[Unset, Payload30Type] = UNSET,
        **kwargs,
    ) -> 'Response[Index]':
        url = f'/databases/{database_id}/collections/{collection_id}/indexes'

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(Payload30, json)
        json = (
            json.dict(by_alias=True) if isinstance(json, BaseModel) else json
        )

        headers = {}
        return await self._appwrite.arequest(
            'POST',
            url,
            json=exclude_unset(json),
            response_model=Index,
        )

    def databases_get_index(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response[Index]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/indexes/{key}'

        return self._appwrite.request(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Index,
        )

    async def async_databases_get_index(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response[Index]':
        url = f'/databases/{database_id}/collections/{collection_id}/indexes/{key}'

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            headers=exclude_unset(headers),
            response_model=Index,
        )

    def databases_delete_index(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/indexes/{key}'

        return self._appwrite.request(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    async def async_databases_delete_index(
        self,
        database_id: str,
        collection_id: str,
        key: str,
    ) -> 'Response':
        url = f'/databases/{database_id}/collections/{collection_id}/indexes/{key}'

        headers = {}
        return await self._appwrite.arequest(
            'DELETE',
            url,
            headers=exclude_unset(headers),
        )

    def databases_list_collection_logs(
        self,
        database_id: str,
        collection_id: str,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
    ) -> 'Response[LogList]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/logs'

        params = {
            'limit': limit,
            'offset': offset,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=LogList,
        )

    async def async_databases_list_collection_logs(
        self,
        database_id: str,
        collection_id: str,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
    ) -> 'Response[LogList]':
        url = f'/databases/{database_id}/collections/{collection_id}/logs'

        params = {
            'limit': limit,
            'offset': offset,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=LogList,
        )

    def databases_get_collection_usage(
        self,
        database_id: str,
        collection_id: str,
        range_: Union[Unset, str] = '30d',
    ) -> 'Response[UsageCollection]':
        headers = {}
        url = f'/databases/{database_id}/collections/{collection_id}/usage'

        params = {
            'range': range_,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=UsageCollection,
        )

    async def async_databases_get_collection_usage(
        self,
        database_id: str,
        collection_id: str,
        range_: Union[Unset, str] = '30d',
    ) -> 'Response[UsageCollection]':
        url = f'/databases/{database_id}/collections/{collection_id}/usage'

        params = {
            'range': range_,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=UsageCollection,
        )

    def databases_list_logs(
        self,
        database_id: str,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
    ) -> 'Response[LogList]':
        headers = {}
        url = f'/databases/{database_id}/logs'

        params = {
            'limit': limit,
            'offset': offset,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=LogList,
        )

    async def async_databases_list_logs(
        self,
        database_id: str,
        limit: Union[Unset, int] = 25,
        offset: Union[Unset, int] = 0,
    ) -> 'Response[LogList]':
        url = f'/databases/{database_id}/logs'

        params = {
            'limit': limit,
            'offset': offset,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=LogList,
        )

    def databases_get_database_usage(
        self,
        database_id: str,
        range_: Union[Unset, str] = '30d',
    ) -> 'Response[UsageDatabase]':
        headers = {}
        url = f'/databases/{database_id}/usage'

        params = {
            'range': range_,
        }

        return self._appwrite.request(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=UsageDatabase,
        )

    async def async_databases_get_database_usage(
        self,
        database_id: str,
        range_: Union[Unset, str] = '30d',
    ) -> 'Response[UsageDatabase]':
        url = f'/databases/{database_id}/usage'

        params = {
            'range': range_,
        }

        headers = {}
        return await self._appwrite.arequest(
            'GET',
            url,
            params=exclude_unset(params),
            headers=exclude_unset(headers),
            response_model=UsageDatabase,
        )
