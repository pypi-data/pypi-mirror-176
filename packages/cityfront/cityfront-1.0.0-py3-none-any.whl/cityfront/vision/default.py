"""DO NOT EDIT THIS FILE!

This file is auto generated by github rest api discription.
See https://github.com/github/rest-api-description for more information.
"""


from typing import TYPE_CHECKING, Any, List, Union, overload

from cityfront.utils import UNSET, Unset, exclude_unset
from pydantic import BaseModel, parse_obj_as

from .models import (AnswerQuestion, BareImgParams, GetQuestion,
                     HTTPValidationError, Question, QuestionStats,
                     SerpImageResult, UserDetached)
from .types import (AnswerQuestionType, BareImgParamsType, GetQuestionType,
                    UserDetachedType)

if TYPE_CHECKING:
    from cityfront import AppWrite
    from cityfront.response import Response

class DefaultClient:
    def __init__(self, appwrite: "AppWrite"):
        self._appwrite = appwrite

    def get_home__get(
        self,
        


    ) -> "Response[Any]":
        headers = {}
        url = "/"


        return self._appwrite.request(
            "GET",
            url,
            response_model=Any,

        )

    async def async_get_home__get(
        self,
        


    ) -> "Response[Any]":
        url = "/"


        headers = {}
        return await self._appwrite.arequest(
            "GET",
            url,
            response_model=Any,

        )

    def list_users_users_get(
        self,
        
        take: Union[Unset, int] = 10,


    ) -> "Response[List[UserDetached]]":
        headers = {}
        url = "/users"

        params = {
            "take": take,
        }


        return self._appwrite.request(
            "GET",
            url,
            params=exclude_unset(params),
            response_model=List[UserDetached],
            error_models={
                "422": HTTPValidationError,

            },

        )

    async def async_list_users_users_get(
        self,
        
        take: Union[Unset, int] = 10,


    ) -> "Response[List[UserDetached]]":
        url = "/users"

        params = {
            "take": take,
        }


        headers = {}
        return await self._appwrite.arequest(
            "GET",
            url,
            params=exclude_unset(params),
            response_model=List[UserDetached],
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    def create_user_users_post(
        self,
        


        *,
        data: UserDetachedType

    ) -> "Response[UserDetached]":
        ...

    @overload
    def create_user_users_post(
        self,
        


        *,
        data: Unset = UNSET,
        id: int,
        email: str,
        name: Union[Unset, str] = UNSET,
        fdb_ref: str,


    ) -> "Response[UserDetached]":
        ...

    def create_user_users_post(
        self,
        

        *,
        data: Union[Unset, UserDetachedType] = UNSET,
        **kwargs
    ) -> "Response[UserDetached]":
        headers = {}
        url = "/users"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            UserDetached,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        return self._appwrite.request(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=UserDetached,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    async def async_create_user_users_post(
        self,
        


        *,
        data: UserDetachedType

    ) -> "Response[UserDetached]":
        ...

    @overload
    async def async_create_user_users_post(
        self,
        


        *,
        data: Unset = UNSET,
        id: int,
        email: str,
        name: Union[Unset, str] = UNSET,
        fdb_ref: str,


    ) -> "Response[UserDetached]":
        ...

    async def async_create_user_users_post(
        self,
        

        *,
        data: Union[Unset, UserDetachedType] = UNSET,
        **kwargs
    ) -> "Response[UserDetached]":
        url = "/users"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            UserDetached,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        headers = {}
        return await self._appwrite.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=UserDetached,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    def get_imgs_images_post(
        self,
        


        *,
        data: BareImgParamsType

    ) -> "Response[SerpImageResult]":
        ...

    @overload
    def get_imgs_images_post(
        self,
        


        *,
        data: Unset = UNSET,
        query: str,
        page: Union[Unset, int] = 0,


    ) -> "Response[SerpImageResult]":
        ...

    def get_imgs_images_post(
        self,
        

        *,
        data: Union[Unset, BareImgParamsType] = UNSET,
        **kwargs
    ) -> "Response[SerpImageResult]":
        headers = {}
        url = "/images"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            BareImgParams,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        return self._appwrite.request(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=SerpImageResult,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    async def async_get_imgs_images_post(
        self,
        


        *,
        data: BareImgParamsType

    ) -> "Response[SerpImageResult]":
        ...

    @overload
    async def async_get_imgs_images_post(
        self,
        


        *,
        data: Unset = UNSET,
        query: str,
        page: Union[Unset, int] = 0,


    ) -> "Response[SerpImageResult]":
        ...

    async def async_get_imgs_images_post(
        self,
        

        *,
        data: Union[Unset, BareImgParamsType] = UNSET,
        **kwargs
    ) -> "Response[SerpImageResult]":
        url = "/images"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            BareImgParams,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        headers = {}
        return await self._appwrite.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=SerpImageResult,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    def get_question_question_post(
        self,
        


        *,
        data: GetQuestionType

    ) -> "Response[Question]":
        ...

    @overload
    def get_question_question_post(
        self,
        


        *,
        data: Unset = UNSET,
        user_ref: str,


    ) -> "Response[Question]":
        ...

    def get_question_question_post(
        self,
        

        *,
        data: Union[Unset, GetQuestionType] = UNSET,
        **kwargs
    ) -> "Response[Question]":
        headers = {}
        url = "/question"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            GetQuestion,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        return self._appwrite.request(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=Question,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    async def async_get_question_question_post(
        self,
        


        *,
        data: GetQuestionType

    ) -> "Response[Question]":
        ...

    @overload
    async def async_get_question_question_post(
        self,
        


        *,
        data: Unset = UNSET,
        user_ref: str,


    ) -> "Response[Question]":
        ...

    async def async_get_question_question_post(
        self,
        

        *,
        data: Union[Unset, GetQuestionType] = UNSET,
        **kwargs
    ) -> "Response[Question]":
        url = "/question"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            GetQuestion,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        headers = {}
        return await self._appwrite.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=Question,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    def answer_question_answer_post(
        self,
        


        *,
        data: AnswerQuestionType

    ) -> "Response[Any]":
        ...

    @overload
    def answer_question_answer_post(
        self,
        


        *,
        data: Unset = UNSET,
        user_ref: str,
        answer: int,
        question_id: int,


    ) -> "Response[Any]":
        ...

    def answer_question_answer_post(
        self,
        

        *,
        data: Union[Unset, AnswerQuestionType] = UNSET,
        **kwargs
    ) -> "Response[Any]":
        headers = {}
        url = "/answer"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            AnswerQuestion,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        return self._appwrite.request(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=Any,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    async def async_answer_question_answer_post(
        self,
        


        *,
        data: AnswerQuestionType

    ) -> "Response[Any]":
        ...

    @overload
    async def async_answer_question_answer_post(
        self,
        


        *,
        data: Unset = UNSET,
        user_ref: str,
        answer: int,
        question_id: int,


    ) -> "Response[Any]":
        ...

    async def async_answer_question_answer_post(
        self,
        

        *,
        data: Union[Unset, AnswerQuestionType] = UNSET,
        **kwargs
    ) -> "Response[Any]":
        url = "/answer"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            AnswerQuestion,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        headers = {}
        return await self._appwrite.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=Any,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    def question_stats_stats_post(
        self,
        


        *,
        data: GetQuestionType

    ) -> "Response[QuestionStats]":
        ...

    @overload
    def question_stats_stats_post(
        self,
        


        *,
        data: Unset = UNSET,
        user_ref: str,


    ) -> "Response[QuestionStats]":
        ...

    def question_stats_stats_post(
        self,
        

        *,
        data: Union[Unset, GetQuestionType] = UNSET,
        **kwargs
    ) -> "Response[QuestionStats]":
        headers = {}
        url = "/stats"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            GetQuestion,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        return self._appwrite.request(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=QuestionStats,
            error_models={
                "422": HTTPValidationError,

            },

        )

    @overload
    async def async_question_stats_stats_post(
        self,
        


        *,
        data: GetQuestionType

    ) -> "Response[QuestionStats]":
        ...

    @overload
    async def async_question_stats_stats_post(
        self,
        


        *,
        data: Unset = UNSET,
        user_ref: str,


    ) -> "Response[QuestionStats]":
        ...

    async def async_question_stats_stats_post(
        self,
        

        *,
        data: Union[Unset, GetQuestionType] = UNSET,
        **kwargs
    ) -> "Response[QuestionStats]":
        url = "/stats"

        if not kwargs:
            kwargs = UNSET

        json = kwargs if data is UNSET else data
        json = parse_obj_as(
            GetQuestion,
            json
        )
        json = json.dict(by_alias=True) if isinstance(json, BaseModel) else json


        headers = {}
        return await self._appwrite.arequest(
            "POST",
            url,
            json=exclude_unset(json),
            response_model=QuestionStats,
            error_models={
                "422": HTTPValidationError,

            },

        )

