# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['version_manager',
 'version_manager.custom',
 'version_manager.matchers',
 'version_manager.tests']

package_data = \
{'': ['*']}

modules = \
['py']
install_requires = \
['PyYAML==6.0', 'colorama==0.4.6', 'termcolor-util==2022.11.1']

entry_points = \
{'console_scripts': ['version-manager = version_manager.__main__:main',
                     'vm = version_manager.__main__:main']}

setup_kwargs = {
    'name': 'vm',
    'version': '2022.11.1',
    'description': 'version manager manages versions and patches files',
    'long_description': 'Updates versions across multiple files.\n\nInstall\n=======\n\n    pip install vm\n\nUsage\n=====\n\nYou need a `versions.json`, or a `versions.yml` where you can specify\nfor what you’re tracking the versions, and what files to be updated\nusing glob patterns:\n\n    germanium:\n      version: 1.10.3\n      files:\n        README.*: "^(germanium )(.*?)$"\n        setup.py: "version=\'**VERSION**\',"\n        doc/usage/index.adoc: "^(= Germanium v)(.*?)$"\n        germanium/version.py: "current = \\"**VERSION**\\""\n\nHelp:\n\n    usage: version-manager [-h] [--display NAME] [--all]\n                           [--set NAME=VAL [NAME=VAL ...]] [--load FILE] [-t]\n                           [--ignore-missing-parents] [--version]\n\n    Versions processor\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      --display NAME, -d NAME\n                            Display the version of a single tracked version.\n      --all, -a, --list     Display all the tracked versions and their values.\n      --set NAME=VAL [NAME=VAL ...], -s NAME=VAL [NAME=VAL ...]\n                            Set values overriding what\'s in the yml files.\n      --load FILE, -l FILE  Override versions from the given yml file.\n      -t, --tag-name, --tag\n                            Get the current name to use in general tags. If the\n                            branch name can\'t be detected from the git repo, the\n                            $BRANCH_NAME environment variable will be used.\n      --ignore-missing-parents\n                            Ignore missing parents, and simply don\'t patch the\n                            values. Upstream values are still being patched if\n                            existing.\n      --version             Show the currently installed program version (2.5.1)\n\nSpecifying Versions\n===================\n\nThe version value will be expanded using the shell if it contains a \'$\'\nor a \'’, so you can have a version such as:\n\n    "description": {\n      "version": "Built at $(date) on $(uname -n)"\n    }\n\nor YAML:\n\n    description:\n      version: Built at $(date) on $(uname -n)\n\nVersions can also refer to other version files, and extract properties\nfrom there, using the `parent:` notation in the version:\n\n    "germaniumdrivers": {\n      "version": "parent:../germanium/@germaniumdrivers"\n    }\n\n    germaniumdrivers:\n      version: "parent:../germanium/@germaniumdrivers"\n\nThe path will point to the `versions.json/yml` file, or to the folder\nthat contains the `versions.json/yml` file, and after that fill will be\nread and interpreted the `germaniumdrivers` version will be used.\n\nVersions can be also manually overriden from the command line, using the\n`--set` or `-s` flag, for example:\n\n    version-manager -s germanium=2.0.8\n\nThis will ignore the value specified in the versions.yml file, and use\nthe specified one.\n\nFeature Branches\n================\n\nThe version can also be prefixed by `upstream:`. In that case if the\ncurrently checked out branch name contains `-x-`, or the exported\nBRANCH\\_NAME environment variable has that name, the version returned by\n`version-manager --tag` will be used instead.\n\n    germaniumdrivers:\n      version: "upstream:1.1.0"\n\nAs long as the branch is not marked to contain cross feature branches\ndependencies with `-x-` it will return `1.1.0`.\n\nThis also works for parent branches, so you can have:\n\n    germaniumdrivers:\n      version: "parent:upstream:../germanium/@germaniumdrivers"\n\nIf the branch name is for example: `feature/UI-123-x-test-new-drivers`\nthe `parent:` value will not be read, and\n`0.1-feature_UI-123-x-test-new-drivers` will be returned as the value.\n\nFile Matchers\n=============\n\nThere are currently only three file matchers:\n\nRegExp File Matcher\n-------------------\n\nIt is a RegExp that has two or three groups, and it will have the second\ngroup replaced to the matched version.\n\n**VERSION** File Matcher\n------------------------\n\nThis will construct a RegExp that will match exactly the given text,\nwith the `VERSION` being the second group.\n\nSo having a matcher such as:\n\n    "files": {\n        "README": "This installs version **VERSION** of the product."\n    }\n\nor yaml\n\n    files:\n      README: This installs version **VERSION** of the product.\n\nis equivalent with:\n\n    "files": {\n        "README": "(This installs version )(.+?)( of the product\\\\.)"\n    }\n\nor yaml\n\n    files:\n      README: (This installs version )(.+?)( of the product\\\\.)\n\nIf the `` **`s are replaced with `^^ `` at the beginning, or\n`` ` at the end, they\nwill act as RegExp anchors, equivalent to `^` and `$`. In case in the\nexpression there is content before the `^^`, or after the ` ``, the\ncontent is ignored.\n\nmaven: File Matcher\n-------------------\n\nThis will construct a RegExp that will match:\n\n    `(<groupId>${m[1]}</groupId>\\\\s*` +\n    `<artifactId>${m[2]}</artifactId>\\\\s*` +\n    `<version>)(.*?)(</version>)`;\n\nIn order to specify the matcher, just use:\n\n    {"germanium": {\n      "version": "2.0.0",\n      "files": {\n        "pom.xml": "maven:com.germaniumhq:germanium"\n      }\n    }\n\nor yaml\n\n    germanium:\n      version: 2.0.0\n      files:\n        pom.xml: maven:com.germaniumhq:germanium\n\nMatcher Constraints\n===================\n\nIn order to make sure that the expressions are not replacing in too many\nplaces, constraints can be added to limit, or extend the matches.\n\nMatcher constraints are always active, and in case no constraint is\nspecified then the maximum replacement count is set to 1.\n\nMatch Count\n-----------\n\n    {\n      "product" : {\n        "version": "1.0",\n        "files": {\n          "README.md": {\n            "match": "^(= Germanium v)(.*?)$",\n            "count": 2\n          }\n        }\n      }\n    }\n\nor yaml\n\n    product:\n      version: "1.0"\n      files:\n        README.md:\n          match: ^(= Germanium v)(.*?)$\n          count: 2\n\nThe count can be also `0` for no matches, or negative to indicate any\nnumber of matches is allowed.\n\nMultiple Matchers\n=================\n\nIn a single file, we can have multiple matchers as well, for example:\n\n    {\n      "product" : {\n        "version": "1.0",\n        "files": {\n          "README.md": [\n            "^(= Germanium v)(.*?)$",\n            "(Germanium )(\\\\d+\\\\.\\\\d+)()"\n          ]\n        }\n      }\n    }\n\nFor each matcher that is added, if there is no match count specified,\nit’s assumed that it will only match once in the file.\n\nOf course, constraints can be applied for both the full set of matchers:\n\n    {\n      "product" : {\n        "version": "1.0",\n        "files": {\n          "README.md": {\n            "match": [\n              "^(= Germanium v)(.*?)$",\n              "(Germanium )(\\\\d+\\\\.\\\\d+)()"\n            ],\n            "count": 3\n          }\n        }\n      }\n    }\n\nor even individual expressions:\n\n    {\n      "product" : {\n        "version": "1.0",\n        "files": {\n          "README.md": {\n            "match": [\n              "^(= Germanium v)(.*?)$",\n              {\n                "match": "(Germanium )(\\\\d+\\\\.\\\\d+)()",\n                "count": 2\n              }\n            ],\n            "count": 3\n          }\n        }\n      }\n    }\n\nNotes\n=====\n\n1.  Files are actually `glob` patterns, so you can match `*/.js` for\n    example.\n\n2.  The configuration files can be yml.\n\n3.  `vm` will output the following error codes: 0 when no files are\n    changed, 0 when files are changed successfuly, or a non zero error\n    code in case of error.\n\n\n',
    'author': 'Bogdan Mustiata',
    'author_email': 'bogdan.mustiata@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'py_modules': modules,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
