{"version":3,"file":"chunks/app_components_replays_replayPlayer_tsx-app_components_replays_replaysFeatureBadge_tsx-app_ut-8d4b7f.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/replays/player/bufferingOverlay.tsx","webpack:///./app/components/replays/player/fastForwardBadge.tsx","webpack:///./app/components/replays/playerDOMAlert.tsx","webpack:///./app/components/replays/replayPlayer.tsx","webpack:///./app/components/replays/replaysFeatureBadge.tsx","webpack:///./app/utils/replays/replayReader.tsx","webpack:///./app/utils/replays/hooks/useReplayData.tsx","webpack:///./app/utils/replays/flattenListOfObjects.tsx","webpack:///./app/views/replays/detail/layout/fluidHeight.tsx"],"sourcesContent":["import styled from '@emotion/styled';\n\nimport {IconClock} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\ntype Props = {\n  className?: string;\n};\n\nfunction BufferingOverlay({className}: Props) {\n  return (\n    <Overlay className={className}>\n      <Message>\n        <IconClock size=\"sm\" />\n        {t('Buffering...')}\n      </Message>\n    </Overlay>\n  );\n}\n\n/* Position the badge in the corner */\nconst Overlay = styled('div')`\n  user-select: none;\n  display: grid;\n  place-items: center;\n`;\n\n/* Badge layout and style */\nconst Message = styled('div')`\n  display: grid;\n  grid-template-columns: max-content max-content;\n  gap: ${space(0.75)};\n  place-items: center;\n\n  padding: ${space(3)};\n  background: ${p => p.theme.gray300};\n  border-radius: ${p => p.theme.borderRadius};\n  color: ${p => p.theme.white};\n  z-index: ${p => p.theme.zIndex.initial};\n`;\n\nexport default BufferingOverlay;\n","import styled from '@emotion/styled';\n\nimport Tooltip from 'sentry/components/tooltip';\nimport {IconArrow} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\ntype Props = {\n  speed: number;\n  className?: string;\n};\n\nfunction FastForwardBadge({speed, className}: Props) {\n  return (\n    <Badge className={className}>\n      <FastForwardTooltip title={t('Fast forwarding at %sx', speed)}>\n        {t('Fast forwarding through inactivity')}\n        <IconArrow size=\"sm\" direction=\"right\" />\n      </FastForwardTooltip>\n    </Badge>\n  );\n}\n\n/* Position the badge in the corner */\nconst Badge = styled('div')`\n  user-select: none;\n  display: grid;\n  align-items: end;\n  justify-items: start;\n`;\n\n/* Badge layout and style */\nconst FastForwardTooltip = styled(Tooltip)`\n  display: grid;\n  grid-template-columns: max-content max-content;\n  gap: ${space(0.5)};\n  align-items: center;\n\n  background: ${p => p.theme.gray300};\n  color: ${p => p.theme.white};\n  padding: ${space(1.5)} ${space(2)};\n  border-top-right-radius: ${p => p.theme.borderRadius};\n  z-index: ${p => p.theme.zIndex.initial};\n`;\n\nexport default FastForwardBadge;\n","import {useEffect, useState} from 'react';\nimport styled from '@emotion/styled';\n\nimport Button from 'sentry/components/button';\nimport {IconClose, IconInfo} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\nimport localStorage from 'sentry/utils/localStorage';\n\nconst LOCAL_STORAGE_KEY = 'replay-player-dom-alert-dismissed';\n\nfunction PlayerDOMAlert() {\n  const [isDismissed, setIsDismissed] = useState(true);\n\n  const handleDismiss = () => {\n    localStorage.setItem(LOCAL_STORAGE_KEY, '1');\n    setIsDismissed(true);\n  };\n\n  useEffect(() => {\n    const val = localStorage.getItem(LOCAL_STORAGE_KEY);\n    setIsDismissed(val === '1');\n  }, []);\n\n  if (isDismissed) {\n    return null;\n  }\n\n  return (\n    <DOMAlertContainer data-test-id=\"player-dom-alert\">\n      <DOMAlert>\n        <IconInfo size=\"xs\" />\n        {t(\"Right click & inspect your app's DOM\")}\n        <DismissButton\n          priority=\"link\"\n          size=\"sm\"\n          icon={<IconClose size=\"xs\" />}\n          aria-label={t('Close Alert')}\n          onClick={handleDismiss}\n        />\n      </DOMAlert>\n    </DOMAlertContainer>\n  );\n}\n\nexport default PlayerDOMAlert;\n\nconst DOMAlertContainer = styled('div')`\n  position: absolute;\n  bottom: ${space(1)};\n  left: 0;\n  width: 100%;\n  text-align: center;\n  font-size: ${p => p.theme.fontSizeMedium};\n  pointer-events: none;\n`;\n\nconst DOMAlert = styled('div')`\n  display: inline-flex;\n  align-items: center;\n  justify-items: center;\n  padding: ${space(1)} ${space(2)};\n  margin: 0 ${space(1)};\n  color: ${p => p.theme.white};\n  background-color: ${p => p.theme.blue400};\n  border-radius: ${p => p.theme.borderRadius};\n  gap: 0 ${space(1)};\n  line-height: 0;\n`;\n\nconst DismissButton = styled(Button)`\n  color: ${p => p.theme.white};\n  pointer-events: all;\n  &:hover {\n    color: ${p => p.theme.white};\n    opacity: 0.5;\n  }\n`;\n","import React, {useCallback, useEffect, useRef, useState} from 'react';\nimport styled from '@emotion/styled';\nimport {useResizeObserver} from '@react-aria/utils';\n\nimport {Panel as _Panel} from 'sentry/components/panels';\nimport BufferingOverlay from 'sentry/components/replays/player/bufferingOverlay';\nimport FastForwardBadge from 'sentry/components/replays/player/fastForwardBadge';\nimport {useReplayContext} from 'sentry/components/replays/replayContext';\n\nimport PlayerDOMAlert from './playerDOMAlert';\n\ninterface Props {\n  className?: string;\n}\n\nfunction BasePlayerRoot({className}: Props) {\n  const {\n    initRoot,\n    dimensions: videoDimensions,\n    fastForwardSpeed,\n    isBuffering,\n  } = useReplayContext();\n\n  const windowEl = useRef<HTMLDivElement>(null);\n  const viewEl = useRef<HTMLDivElement>(null);\n\n  const [windowDimensions, setWindowDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  // Create the `rrweb` instance which creates an iframe inside `viewEl`\n  useEffect(() => initRoot(viewEl.current), [initRoot]);\n\n  // Read the initial width & height where the player will be inserted, this is\n  // so we can shrink the video into the available space.\n  // If the size of the container changes, we can re-calculate the scaling factor\n  const updateWindowDimensions = useCallback(\n    () =>\n      setWindowDimensions({\n        width: windowEl.current?.clientWidth || 0,\n        height: windowEl.current?.clientHeight || 0,\n      }),\n    [setWindowDimensions]\n  );\n  useResizeObserver({ref: windowEl, onResize: updateWindowDimensions});\n  // If your browser doesn't have ResizeObserver then set the size once.\n  useEffect(() => {\n    if (typeof window.ResizeObserver !== 'undefined') {\n      return;\n    }\n    updateWindowDimensions();\n  }, [updateWindowDimensions]);\n\n  // Update the scale of the view whenever dimensions have changed.\n  useEffect(() => {\n    if (viewEl.current) {\n      const scale = Math.min(\n        windowDimensions.width / videoDimensions.width,\n        windowDimensions.height / videoDimensions.height,\n        1\n      );\n      if (scale) {\n        viewEl.current.style['transform-origin'] = 'top left';\n        viewEl.current.style.transform = `scale(${scale})`;\n        viewEl.current.style.width = `${videoDimensions.width * scale}px`;\n        viewEl.current.style.height = `${videoDimensions.height * scale}px`;\n      }\n    }\n  }, [windowDimensions, videoDimensions]);\n\n  return (\n    <SizingWindow ref={windowEl} className=\"sentry-block\">\n      <div ref={viewEl} className={className} />\n      {fastForwardSpeed ? <PositionedFastForward speed={fastForwardSpeed} /> : null}\n      {isBuffering ? <PositionedBuffering /> : null}\n      <PlayerDOMAlert />\n    </SizingWindow>\n  );\n}\n\n// Center the viewEl inside the windowEl.\n// This is useful when the window is inside a container that has large fixed\n// dimensions, like when in fullscreen mode.\n// If the container has a dimensions that can grow/shrink then it is\n// important to also set `overflow: hidden` on the container, so that the\n// SizingWindow can calculate size as things shrink.\nconst SizingWindow = styled('div')`\n  width: 100%;\n  display: flex;\n  flex-grow: 1;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  overflow: hidden;\n\n  background-color: ${p => p.theme.backgroundSecondary};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${p => p.theme.backgroundSecondary} 8px,\n      ${p => p.theme.backgroundSecondary} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${p => p.theme.gray100} 15px,\n      ${p => p.theme.gray100} 16px\n    );\n`;\n\nconst PositionedFastForward = styled(FastForwardBadge)`\n  position: absolute;\n  left: 0;\n  bottom: 0;\n`;\n\nconst PositionedBuffering = styled(BufferingOverlay)`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n`;\n\n// Base styles, to make the Replayer instance work\nconst PlayerRoot = styled(BasePlayerRoot)`\n  .replayer-wrapper {\n    user-select: none;\n  }\n  .replayer-wrapper > .replayer-mouse-tail {\n    position: absolute;\n    pointer-events: none;\n  }\n\n  /* Override default user-agent styles */\n  .replayer-wrapper > iframe {\n    border: none;\n    background: white;\n  }\n`;\n\n// Sentry-specific styles for the player.\n// The elements we have to work with are:\n// ```css\n// div.replayer-wrapper {}\n// div.replayer-wrapper > div.replayer-mouse {}\n// div.replayer-wrapper > canvas.replayer-mouse-tail {}\n// div.replayer-wrapper > iframe {}\n// ```\n// The mouse-tail is also configured for color/size in `app/components/replays/replayContext.tsx`\nconst SentryPlayerRoot = styled(PlayerRoot)`\n  .replayer-mouse {\n    position: absolute;\n    width: 32px;\n    height: 32px;\n    transition: left 0.05s linear, top 0.05s linear;\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTkiIHZpZXdCb3g9IjAgMCAxMiAxOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTZWMEwxMS42IDExLjZINC44TDQuNCAxMS43TDAgMTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNOS4xIDE2LjdMNS41IDE4LjJMMC43OTk5OTkgNy4xTDQuNSA1LjZMOS4xIDE2LjdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNC42NzQ1MSA4LjYxODUxTDIuODMwMzEgOS4zOTI3MUw1LjkyNzExIDE2Ljc2OTVMNy43NzEzMSAxNS45OTUzTDQuNjc0NTEgOC42MTg1MVoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik0xIDIuNFYxMy42TDQgMTAuN0w0LjQgMTAuNkg5LjJMMSAyLjRaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K');\n    border-color: transparent;\n  }\n  .replayer-mouse:after {\n    content: '';\n    display: inline-block;\n    width: 32px;\n    height: 32px;\n    background: ${p => p.theme.purple300};\n    border-radius: 100%;\n    transform: translate(-50%, -50%);\n    opacity: 0.3;\n  }\n  .replayer-mouse.active:after {\n    animation: click 0.2s ease-in-out 1;\n  }\n  .replayer-mouse.touch-device {\n    background-image: none;\n    width: 70px;\n    height: 70px;\n    border-radius: 100%;\n    margin-left: -37px;\n    margin-top: -37px;\n    border: 4px solid rgba(73, 80, 246, 0);\n    transition: left 0s linear, top 0s linear, border-color 0.2s ease-in-out;\n  }\n  .replayer-mouse.touch-device.touch-active {\n    border-color: ${p => p.theme.purple200};\n    transition: left 0.25s linear, top 0.25s linear, border-color 0.2s ease-in-out;\n  }\n  .replayer-mouse.touch-device:after {\n    opacity: 0;\n  }\n  .replayer-mouse.touch-device.active:after {\n    animation: touch-click 0.2s ease-in-out 1;\n  }\n  @keyframes click {\n    0% {\n      opacity: 0.3;\n      width: 20px;\n      height: 20px;\n    }\n    50% {\n      opacity: 0.5;\n      width: 10px;\n      height: 10px;\n    }\n  }\n  @keyframes touch-click {\n    0% {\n      opacity: 0;\n      width: 20px;\n      height: 20px;\n    }\n    50% {\n      opacity: 0.5;\n      width: 10px;\n      height: 10px;\n    }\n  }\n`;\n\nexport default SentryPlayerRoot;\n","import FeatureBadge from 'sentry/components/featureBadge';\n\nfunction ReplaysFeatureBadge(\n  props: Omit<React.ComponentProps<typeof FeatureBadge>, 'type'>\n) {\n  return <FeatureBadge {...props} type=\"beta\" />;\n}\n\nexport default ReplaysFeatureBadge;\n","import {duration} from 'moment';\n\nimport type {Crumb} from 'sentry/types/breadcrumbs';\nimport {\n  breadcrumbFactory,\n  getBreadcrumbsByCategory,\n  isMemorySpan,\n  isNetworkSpan,\n  replayTimestamps,\n  rrwebEventListFactory,\n  spansFactory,\n} from 'sentry/utils/replays/replayDataUtils';\nimport type {\n  MemorySpanType,\n  RecordingEvent,\n  ReplayCrumb,\n  ReplayError,\n  ReplayRecord,\n  ReplaySpan,\n} from 'sentry/views/replays/types';\n\ninterface ReplayReaderParams {\n  breadcrumbs: ReplayCrumb[] | undefined;\n  errors: ReplayError[] | undefined;\n\n  /**\n   * The root Replay event, created at the start of the browser session.\n   */\n  replayRecord: ReplayRecord | undefined;\n\n  /**\n   * The captured data from rrweb.\n   * Saved as N attachments that belong to the root Replay event.\n   */\n  rrwebEvents: RecordingEvent[] | undefined;\n\n  spans: ReplaySpan[] | undefined;\n}\n\ntype RequiredNotNull<T> = {\n  [P in keyof T]: NonNullable<T[P]>;\n};\n\nexport default class ReplayReader {\n  static factory({\n    breadcrumbs,\n    replayRecord,\n    errors,\n    rrwebEvents,\n    spans,\n  }: ReplayReaderParams) {\n    if (!breadcrumbs || !replayRecord || !rrwebEvents || !spans || !errors) {\n      return null;\n    }\n\n    return new ReplayReader({breadcrumbs, replayRecord, errors, rrwebEvents, spans});\n  }\n\n  private constructor({\n    breadcrumbs,\n    replayRecord,\n    errors,\n    rrwebEvents,\n    spans,\n  }: RequiredNotNull<ReplayReaderParams>) {\n    // TODO(replays): We should get correct timestamps from the backend instead\n    // of having to fix them up here.\n    const {startTimestampMs, endTimestampMs} = replayTimestamps(\n      replayRecord,\n      rrwebEvents,\n      breadcrumbs,\n      spans\n    );\n    replayRecord.startedAt = new Date(startTimestampMs);\n    replayRecord.finishedAt = new Date(endTimestampMs);\n    replayRecord.duration = duration(\n      replayRecord.finishedAt.getTime() - replayRecord.startedAt.getTime()\n    );\n\n    const sortedSpans = spansFactory(spans);\n    this.networkSpans = sortedSpans.filter(isNetworkSpan);\n    this.memorySpans = sortedSpans.filter(isMemorySpan);\n\n    this.breadcrumbs = breadcrumbFactory(replayRecord, errors, breadcrumbs, sortedSpans);\n    this.consoleCrumbs = getBreadcrumbsByCategory(this.breadcrumbs, ['console', 'issue']);\n\n    this.rrwebEvents = rrwebEventListFactory(replayRecord, rrwebEvents);\n\n    this.replayRecord = replayRecord;\n  }\n\n  private replayRecord: ReplayRecord;\n  private rrwebEvents: RecordingEvent[];\n  private breadcrumbs: Crumb[];\n  private consoleCrumbs: ReturnType<typeof getBreadcrumbsByCategory>;\n  private networkSpans: ReplaySpan[];\n  private memorySpans: MemorySpanType[];\n\n  /**\n   * @returns Duration of Replay (milliseonds)\n   */\n  getDurationMs = () => {\n    return this.replayRecord.duration.asMilliseconds();\n  };\n\n  getReplay = () => {\n    return this.replayRecord;\n  };\n\n  getRRWebEvents = () => {\n    return this.rrwebEvents;\n  };\n\n  getRawCrumbs = () => {\n    return this.breadcrumbs;\n  };\n\n  getConsoleCrumbs = () => {\n    return this.consoleCrumbs;\n  };\n\n  getNetworkSpans = () => {\n    return this.networkSpans;\n  };\n\n  getMemorySpans = () => {\n    return this.memorySpans;\n  };\n}\n","import {useCallback, useEffect, useMemo, useState} from 'react';\nimport * as Sentry from '@sentry/react';\n\nimport parseLinkHeader, {ParsedHeader} from 'sentry/utils/parseLinkHeader';\nimport flattenListOfObjects from 'sentry/utils/replays/flattenListOfObjects';\nimport {mapResponseToReplayRecord} from 'sentry/utils/replays/replayDataUtils';\nimport ReplayReader from 'sentry/utils/replays/replayReader';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\nimport type {\n  RecordingEvent,\n  ReplayCrumb,\n  ReplayError,\n  ReplayRecord,\n  ReplaySpan,\n} from 'sentry/views/replays/types';\n\ntype State = {\n  breadcrumbs: undefined | ReplayCrumb[];\n\n  /**\n   * List of errors that occurred during replay\n   */\n  errors: undefined | ReplayError[];\n\n  /**\n   * If any request returned an error then nothing is being returned\n   */\n  fetchError: undefined | RequestError;\n\n  /**\n   * If a fetch is underway for the requested root reply.\n   * This includes fetched all the sub-resources like attachments and `sentry-replay-event`\n   */\n  fetching: boolean;\n\n  /**\n   * The root replay event\n   */\n  replayRecord: undefined | ReplayRecord;\n\n  /**\n   * The flattened list of rrweb events. These are stored as multiple attachments on the root replay object: the `event` prop.\n   */\n  rrwebEvents: undefined | RecordingEvent[];\n\n  spans: undefined | ReplaySpan[];\n};\n\ntype Options = {\n  /**\n   * The organization slug\n   */\n\n  orgSlug: string;\n  /**\n   * The projectSlug and replayId concatenated together\n   */\n  replaySlug: string;\n};\n\n// Errors if it is an interface\n// See https://github.com/microsoft/TypeScript/issues/15300\ntype ReplayAttachment = {\n  breadcrumbs: ReplayCrumb[];\n  recording: RecordingEvent[];\n  replaySpans: ReplaySpan[];\n};\n\ninterface Result extends Pick<State, 'fetchError' | 'fetching'> {\n  onRetry: () => void;\n  replay: ReplayReader | null;\n  replayRecord: ReplayRecord | undefined;\n}\n\nexport function mapRRWebAttachments(unsortedReplayAttachments): ReplayAttachment {\n  const replayAttachments: ReplayAttachment = {\n    breadcrumbs: [],\n    replaySpans: [],\n    recording: [],\n  };\n\n  unsortedReplayAttachments.forEach(attachment => {\n    if (attachment.data?.tag === 'performanceSpan') {\n      replayAttachments.replaySpans.push(attachment.data.payload);\n    } else if (attachment?.data?.tag === 'breadcrumb') {\n      replayAttachments.breadcrumbs.push(attachment.data.payload);\n    } else {\n      replayAttachments.recording.push(attachment);\n    }\n  });\n\n  return replayAttachments;\n}\n\nconst INITIAL_STATE: State = Object.freeze({\n  breadcrumbs: undefined,\n  errors: undefined,\n  fetchError: undefined,\n  fetching: true,\n  replayRecord: undefined,\n  rrwebEvents: undefined,\n  spans: undefined,\n});\n\n/**\n * A react hook to load core replay data over the network.\n *\n * Core replay data includes:\n * 1. The root replay EventTransaction object\n *    - This includes `startTimestamp` and `tags` data\n * 2. Breadcrumb and Span data from all the related Event objects\n *    - Data is merged for consumption\n * 3. RRWeb payloads for the replayer video stream\n *    - TODO(replay): incrementally load the stream to speedup pageload\n *\n * This function should stay focused on loading data over the network.\n * Front-end processing, filtering and re-mixing of the different data streams\n * must be delegated to the `ReplayReader` class.\n *\n * @param {orgSlug, replaySlug} Where to find the root replay event\n * @returns An object representing a unified result of the network requests. Either a single `ReplayReader` data object or fetch errors.\n */\nfunction useReplayData({replaySlug, orgSlug}: Options): Result {\n  const [projectSlug, replayId] = replaySlug.split(':');\n\n  const api = useApi();\n  const [state, setState] = useState<State>(INITIAL_STATE);\n\n  // Fetch every field of the replay. We're overfetching, not every field is needed\n  const fetchReplay = useCallback(async () => {\n    const response = await api.requestPromise(\n      `/projects/${orgSlug}/${projectSlug}/replays/${replayId}/`\n    );\n    return response.data;\n  }, [api, orgSlug, projectSlug, replayId]);\n\n  const fetchAllRRwebEvents = useCallback(async () => {\n    const rootUrl = `/projects/${orgSlug}/${projectSlug}/replays/${replayId}/recording-segments/?download`;\n    let next: ParsedHeader = {\n      href: rootUrl,\n      results: true,\n      cursor: '',\n    };\n\n    const segmentRanges: any = [];\n    // TODO(replay): It would be good to load the first page of results then\n    // start to render the UI while the next N pages continue to get fetched in\n    // the background.\n    while (next.results) {\n      const url = rootUrl + '&cursor=' + next.cursor;\n\n      const [data, _textStatus, resp] = await api.requestPromise(url, {\n        includeAllArgs: true,\n      });\n      segmentRanges.push(data);\n      const links = parseLinkHeader(resp?.getResponseHeader('Link') ?? '');\n      next = links.next;\n    }\n\n    const rrwebEvents = segmentRanges\n      .flatMap(segment => segment)\n      .flatMap(attachments => mapRRWebAttachments(attachments));\n\n    return flattenListOfObjects(rrwebEvents);\n  }, [api, orgSlug, projectSlug, replayId]);\n\n  const fetchErrors = useCallback(\n    async (replayRecord: ReplayRecord) => {\n      if (!replayRecord.errorIds.length) {\n        return [];\n      }\n\n      // Clone the `finishedAt` time and bump it up one second because finishedAt\n      // has the `ms` portion truncated, while replays-events-meta operates on\n      // timestamps with `ms` attached. So finishedAt could be at time `12:00:00.000Z`\n      // while the event is saved with `12:00:00.450Z`.\n      const finishedAtClone = new Date(replayRecord.finishedAt);\n      finishedAtClone.setSeconds(finishedAtClone.getSeconds() + 1);\n\n      const response = await api.requestPromise(\n        `/organizations/${orgSlug}/replays-events-meta/`,\n        {\n          query: {\n            start: replayRecord.startedAt.toISOString(),\n            end: finishedAtClone.toISOString(),\n            query: `id:[${String(replayRecord.errorIds)}]`,\n          },\n        }\n      );\n      return response.data;\n    },\n    [api, orgSlug]\n  );\n\n  const fetchReplayAndErrors = useCallback(async (): Promise<[ReplayRecord, any]> => {\n    const fetchedRecord = await fetchReplay();\n    const mappedRecord = mapResponseToReplayRecord(fetchedRecord);\n    setState(prev => ({\n      ...prev,\n      replayRecord: mappedRecord,\n    }));\n    const fetchedErrors = await fetchErrors(mappedRecord);\n    return [mappedRecord, fetchedErrors];\n  }, [fetchReplay, fetchErrors]);\n\n  const loadEvents = useCallback(async () => {\n    setState(INITIAL_STATE);\n\n    try {\n      const [replayAndErrors, attachments] = await Promise.all([\n        fetchReplayAndErrors(),\n        fetchAllRRwebEvents(),\n      ]);\n      const [replayRecord, errors] = replayAndErrors;\n\n      setState(prev => ({\n        ...prev,\n        breadcrumbs: attachments.breadcrumbs,\n        errors,\n        fetchError: undefined,\n        fetching: false,\n        replayRecord,\n        rrwebEvents: attachments.recording,\n        spans: attachments.replaySpans,\n      }));\n    } catch (error) {\n      Sentry.captureException(error);\n      setState({\n        ...INITIAL_STATE,\n        fetchError: error,\n        fetching: false,\n      });\n    }\n  }, [fetchReplayAndErrors, fetchAllRRwebEvents]);\n\n  useEffect(() => {\n    loadEvents();\n  }, [loadEvents]);\n\n  const replay = useMemo(() => {\n    return ReplayReader.factory({\n      breadcrumbs: state.breadcrumbs,\n      errors: state.errors,\n      replayRecord: state.replayRecord,\n      rrwebEvents: state.rrwebEvents,\n      spans: state.spans,\n    });\n  }, [\n    state.breadcrumbs,\n    state.errors,\n    state.replayRecord,\n    state.rrwebEvents,\n    state.spans,\n  ]);\n\n  return {\n    fetchError: state.fetchError,\n    fetching: state.fetching,\n    onRetry: loadEvents,\n    replay,\n    replayRecord: state.replayRecord,\n  };\n}\n\nexport default useReplayData;\n","/**\n * Given a list of objects (or maps) of `string` -> `any[]`,\n * merge the arrays of each key in the object.\n *\n * e.g. [{a: [1]}, {a: [2]}, {b: [3]}] ==> {a: [1, 2], b: {3}}\n *\n * Any non-array values will throw an exception\n */\nexport default function flattenListOfObjects(\n  objs: Array<Record<string, any[] | undefined>>\n) {\n  return objs.reduce((acc, obj) => {\n    Object.entries(obj).forEach(([key, value]) => {\n      if (!Array.isArray(value)) {\n        // e.g. if value is undefined (otherwise, a non-Array type will get caught by ts)\n        // TS doesn't like our test where object keys are no equivalent, so we\n        // need to allow `undefined` as a valid type in the Record.\n        throw new Error('Invalid value');\n      }\n\n      acc[key] = (acc[key] || []).concat(value);\n    });\n\n    return acc;\n  }, {});\n}\n","import styled from '@emotion/styled';\n\nconst FluidHeight = styled('div')`\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  flex-grow: 1;\n  overflow: hidden;\n`;\n\nexport default FluidHeight;\n"],"names":["BufferingOverlay","className","Overlay","Message","size","t","space","p","theme","gray300","borderRadius","white","zIndex","initial","FastForwardBadge","speed","Badge","FastForwardTooltip","title","direction","Tooltip","LOCAL_STORAGE_KEY","PlayerDOMAlert","isDismissed","setIsDismissed","useState","useEffect","val","localStorage","DOMAlertContainer","DOMAlert","DismissButton","priority","icon","onClick","fontSizeMedium","blue400","Button","BasePlayerRoot","initRoot","dimensions","videoDimensions","fastForwardSpeed","isBuffering","useReplayContext","windowEl","useRef","viewEl","windowDimensions","setWindowDimensions","width","height","current","updateWindowDimensions","useCallback","clientWidth","clientHeight","useResizeObserver","ref","onResize","window","ResizeObserver","scale","Math","min","style","transform","SizingWindow","PositionedFastForward","PositionedBuffering","backgroundSecondary","gray100","PlayerRoot","purple300","purple200","ReplaysFeatureBadge","props","type","ReplayReader","static","breadcrumbs","replayRecord","errors","rrwebEvents","spans","constructor","this","duration","asMilliseconds","consoleCrumbs","networkSpans","memorySpans","startTimestampMs","endTimestampMs","replayTimestamps","startedAt","Date","finishedAt","getTime","sortedSpans","spansFactory","filter","isNetworkSpan","isMemorySpan","breadcrumbFactory","getBreadcrumbsByCategory","rrwebEventListFactory","INITIAL_STATE","Object","freeze","undefined","fetchError","fetching","replaySlug","orgSlug","projectSlug","replayId","split","api","useApi","state","setState","fetchReplay","async","requestPromise","data","fetchAllRRwebEvents","rootUrl","next","href","results","cursor","segmentRanges","url","_textStatus","resp","includeAllArgs","push","parseLinkHeader","getResponseHeader","flatMap","segment","attachments","unsortedReplayAttachments","replayAttachments","replaySpans","recording","forEach","attachment","tag","payload","mapRRWebAttachments","reduce","acc","obj","entries","key","value","Array","isArray","Error","concat","fetchErrors","errorIds","length","finishedAtClone","setSeconds","getSeconds","query","start","toISOString","end","String","fetchReplayAndErrors","fetchedRecord","mappedRecord","mapResponseToReplayRecord","prev","fetchedErrors","loadEvents","replayAndErrors","Promise","all","error","Sentry","replay","useMemo","factory","onRetry"],"sourceRoot":""}