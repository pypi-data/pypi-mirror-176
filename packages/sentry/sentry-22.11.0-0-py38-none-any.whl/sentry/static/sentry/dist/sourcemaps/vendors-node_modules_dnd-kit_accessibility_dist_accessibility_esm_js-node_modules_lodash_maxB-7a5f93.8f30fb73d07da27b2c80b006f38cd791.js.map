{"version":3,"file":"chunks/vendors-node_modules_dnd-kit_accessibility_dist_accessibility_esm_js-node_modules_lodash_maxB-7a5f93.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///../node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js","webpack:///../node_modules/lodash/maxBy.js","webpack:///../node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\n\nconst hiddenStyles = {\n  display: 'none'\n};\nfunction HiddenText({\n  id,\n  value\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: hiddenStyles\n  }, value);\n}\n\nconst visuallyHidden = {\n  position: 'absolute',\n  width: 1,\n  height: 1,\n  margin: -1,\n  border: 0,\n  padding: 0,\n  overflow: 'hidden',\n  clip: 'rect(0 0 0 0)',\n  clipPath: 'inset(100%)',\n  whiteSpace: 'nowrap'\n};\nfunction LiveRegion({\n  id,\n  announcement\n}) {\n  return React.createElement(\"div\", {\n    id: id,\n    style: visuallyHidden,\n    role: \"status\",\n    \"aria-live\": \"assertive\",\n    \"aria-atomic\": true\n  }, announcement);\n}\n\nfunction useAnnouncement() {\n  const [announcement, setAnnouncement] = useState('');\n  const announce = useCallback(value => {\n    if (value != null) {\n      setAnnouncement(value);\n    }\n  }, []);\n  return {\n    announce,\n    announcement\n  };\n}\n\nexport { HiddenText, LiveRegion, useAnnouncement };\n//# sourceMappingURL=accessibility.esm.js.map\n","var baseExtremum = require('./_baseExtremum'),\n    baseGt = require('./_baseGt'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * This method is like `_.max` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * the value is ranked. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * _.maxBy(objects, function(o) { return o.n; });\n * // => { 'n': 2 }\n *\n * // The `_.property` iteratee shorthand.\n * _.maxBy(objects, 'n');\n * // => { 'n': 2 }\n */\nfunction maxBy(array, iteratee) {\n  return (array && array.length)\n    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)\n    : undefined;\n}\n\nmodule.exports = maxBy;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c === null || c === void 0 ? void 0 : c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l);\n  var hasCollisions = collisions.length > 0; // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n, allowOverlap\n/*: ?boolean*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  ) {\n    // Child may not exist\n    if ((child === null || child === void 0 ? void 0 : child.key) == null) return; // Don't overwrite if it already exists.\n\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout.push(cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        })));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"],"names":["hiddenStyles","display","HiddenText","id","value","style","visuallyHidden","position","width","height","margin","border","padding","overflow","clip","clipPath","whiteSpace","LiveRegion","announcement","role","useAnnouncement","setAnnouncement","useState","announce","useCallback","baseExtremum","baseGt","baseIteratee","module","exports","array","iteratee","length","undefined","Object","defineProperty","bottom","childrenEqual","a","b","_lodash","default","_react","Children","map","c","key","cloneLayout","cloneLayoutItem","collides","compact","compactItem","compactType","props","_ref3","verticalCompact","correctBounds","fastPositionEqual","left","top","fastRGLPropsEqual","getAllCollisions","getFirstCollision","getLayoutItem","getStatics","modifyLayout","moveElement","moveElementAwayFromCollision","noop","perc","num","setTopLeft","_ref2","concat","setTransform","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","sortLayoutItems","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","initialLayout","children","cols","allowOverlap","layout","forEach","child","exists","String","push","g","_grid","_objectSpread","i","w","h","x","y","correctedLayout","validateLayout","contextName","arguments","subProps","Array","isArray","Error","len","item","j","withLayoutItem","itemKey","cb","_interopRequireDefault","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","apply","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","bottomY","max","newLayout","layoutItem","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","resizeHandles","isBounded","l1","l2","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","moveToCoord","axis","sizeProp","otherItem","fullLayout","compactH","Math","min","bounds","collidesWith","isUserAction","preventCollision","oldX","oldY","reverse","collisions","hasCollisions","collision","itemToMove","compactV","fakeItem","slice","sort"],"sourceRoot":""}